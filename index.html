<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RAG Simulator v2.3</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com/3.4.1"></script>
  <!-- Font Awesome CSS via CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

  <!-- Embedded CSS -->
  <style>
    @keyframes fadeInBlurUp {
        0% {
          opacity: 0;
          filter: blur(10px);
          transform: translateY(20px);
        }
        100% {
          opacity: 1;
          filter: blur(0);
          transform: translateY(0);
        }
      }

      * {
        animation: fadeInBlurUp 0.3s ease forwards;
      }
    html,
    body {
      height: 100%;
      overflow: hidden;
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      font-size: 20px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background-color: #f9fafb; /* gray-50 */
      color: #1f2937; /* gray-800 */
    }
    .main-container {
      display: flex;
      flex-direction: row; /* <-- Add this */
      height: 100vh;
      flex-grow: 1; /* Allow main container to fill vertical space */
      background-color: #f3f4f6;
      padding: 8px; /* Add some padding around the main content */
      gap: 8px; /* Space between left panel and right area */
    }
    /* New styles for left and right panels */
    .left-panel {
      display: flex;
      flex-direction: column;
      width: 350px; /* Adjust width as needed */
      flex-shrink: 0;
      background-color: #ffffff; /* White */
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
      border: 1px solid #e5e7eb; /* gray-200 */
      overflow-y: auto; /* Allow scrolling if buttons overflow */
    }
    .right-area {
      display: flex;
      flex-direction: column;
      flex-grow: 1; /* Take remaining horizontal space */
      gap: 8px; /* Space between canvas and log */
      min-width: 0; /* Prevent overflow issues with flex items */
    }
    .top-bar {
      background-color: transparent; /* Make background transparent, parent handles it */
      padding: 0; /* Remove padding, parent handles it */
      border-radius: 0; /* Remove border-radius */
      box-shadow: none; /* Remove box-shadow */
      border: none; /* Remove border */
      z-index: 10;
      /* Adjust button container flex properties */
      & #buttonContainer {
        display: flex;
        flex-direction: column; /* Stack buttons vertically */
        align-items: stretch; /* Make buttons fill width */
        gap: 6px; /* Space between buttons */
      }
      /* Adjust individual button styles */
      & #buttonContainer button {
        width: 100%; /* Make buttons take full width of panel */
        justify-content: flex-start; /* Align text/icon left */
        padding: 6px 10px; /* Adjust padding */
      }
      & #buttonContainer > span.visualization-control {
         text-align: center; /* Center the viz text */
         margin-bottom: 4px;
      }
    }
    .canvas-container {
      flex-grow: 1; /* Allow canvas container to take up remaining space */
      position: relative; /* Needed for absolute positioning of canvas if required */
      overflow: hidden; /* Hide anything extending beyond the container */
      background-color: #ffffff; /* White background for the canvas area */
      border: 2px solid #d1d5db; /* gray-300 - Increased border width */
      border-radius: 0.375rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -2px rgba(0, 0, 0, 0.1);
      min-height: 300px; /* Adjust min-height if needed */
      transition: background-color 0.3s ease, border-color 0.3s ease; /* Added transition */
    }
    #ragCanvas {
      display: block; /* Remove extra space below canvas */
      width: 100%; /* Make canvas fill container width */
      height: 100%; /* Make canvas fill container height */
      cursor: default;
    }
    #ragCanvas.visualizing {
      cursor: not-allowed;
    }
    .log-container {
      flex-shrink: 0;
      height: 150px; /* Fixed height */
      background-color: #f3f4f6; /* Lighter gray */
      border-top: 1px solid #d1d5db;
      padding: 0.5rem;
      border-radius: 0.375rem;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      overflow-y: auto; /* Enable vertical scrolling */
      font-family: "Consolas", "Monaco", monospace; /* More distinct mono font */
      font-size: 0.875rem; /* 14px */
      line-height: 1.5;
      color: #1f2937; /* Darker text */
      border: 1px solid #e5e7eb; /* gray-200 */
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; /* Added transition */
    }
    .log-entry {
      padding: 2px 6px;
      margin-bottom: 2px;
      border-radius: 3px;
      border: 1px solid transparent; /* Base border */
      transition: background-color 0.2s ease-in-out;
    }
    .log-entry:last-child {
      margin-bottom: 0;
    }
    .log-entry time {
      color: #6b7280; /* gray-500 */
      margin-right: 8px;
      font-size: 0.8em;
      display: inline-block; /* Ensure consistent alignment */
      width: 65px; /* Fixed width for timestamp */
    }

    /* Level-specific styles */
    .log-info {
      background-color: #e0f2fe; /* sky-100 */
      border-color: #7dd3fc; /* sky-300 */
      color: #075985; /* sky-800 */
    }
    .log-success {
      background-color: #dcfce7; /* green-100 */
      border-color: #86efac; /* green-300 */
      color: #166534; /* green-800 */
    }
    .log-success span { font-weight: 500; }
    .log-warn {
      background-color: #fef9c3; /* yellow-100 */
      border-color: #fde047; /* yellow-300 */
      color: #854d0e; /* yellow-800 */
    }
    .log-warn span { font-weight: 500; }
    .log-error {
      background-color: #fee2e2; /* red-100 */
      border-color: #fca5a5; /* red-300 */
      color: #991b1b; /* red-800 */
    }
    .log-error span { font-weight: 600; } /* Semibold */
    .log-viz {
      background-color: #f3e8ff; /* purple-100 */
      border-color: #d8b4fe; /* purple-300 */
      color: #581c87; /* purple-800 */
    }
    .log-viz span { font-style: italic; }
    .log-viz-step {
      background-color: #ede9fe; /* violet-100 */
      border-color: #c4b5fd; /* violet-300 */
      color: #4c1d95; /* violet-800 */
      font-size: 0.9em; /* Slightly smaller for steps */
    }
    .log-viz-step span { font-style: italic; }
    .log-viz-result {
      background-color: #ccfbf1; /* teal-100 */
      border-color: #99f6e4; /* teal-300 */
      color: #115e59; /* teal-800 */
    }
    .log-viz-result span { font-weight: 600; } /* Semibold */
    .log-deadlock {
      background-color: #fecaca; /* red-200 */
      border-color: #f87171; /* red-400 */
      color: #991b1b; /* red-800 */
    }
    .log-deadlock span { font-weight: 700; } /* Bold */

    .modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto; /* Enable scroll if needed */
      /* background-color: rgba(0, 0, 0, 0.5); */
      backdrop-filter: blur(2px);
      /* Use flexbox to center the modal content */
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: #ffffff;
      margin: auto; /* Center horizontally */
      padding: 30px 35px; /* Slightly increase padding */
      border: 1px solid #e5e7eb; /* gray-200 */
      border-radius: 8px;
      width: 50%; /* Default width */
      /* max-width: 550px; */
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -4px rgba(0, 0, 0, 0.15); /* Larger shadow */
      position: relative; /* For positioning the close button */
      transition: background-color 0.3s ease, border-color 0.3s ease; /* Added transition */
    }
    .modal-close-button {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      line-height: 1;
    }
    .modal-close-button:hover,
    .modal-close-button:focus {
      color: #374151; /* gray-700 */
      text-decoration: none;
    }
    .form-input {
      width: 100%;
      padding: 0.6rem 0.85rem; /* Slightly increase padding */
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.95rem; /* Increased from 0.875rem */
      margin-bottom: 0.75rem;
      display: block;
      line-height: 1.25rem;
      color: #1f2937; /* gray-800 */
      background-color: #ffffff;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
      transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, background-color 0.3s ease, color 0.3s ease; /* Added transition */
    }
    .form-input:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
      border-color: #60a5fa;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
      outline: none;
      border-color: #2563eb; /* blue-600 */
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); /* Ring effect */
    }
     .form-input[readonly] {
      background-color: #f3f4f6; /* gray-100 */
      cursor: not-allowed;
      transition: background-color 0.3s ease; /* Added transition */
    }
    textarea.form-input {
        min-height: 110px; /* Slightly increase min-height */
        font-family: inherit; /* Use body font */
    }
    .form-label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.95rem; /* Increased from 0.875rem */
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.5rem;
      transition: color 0.3s ease; /* Added transition */
    }
    .form-button {
      padding: 0.6rem 1.1rem; /* Slightly increase padding */
      border-radius: 0.375rem;
      font-size: 0.95rem; /* Increased from 0.875rem */
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.15s ease-in-out, opacity 0.15s ease-in-out;
      font-weight: 500; /* medium */
      border: 1px solid transparent;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      display: inline-flex; /* Align icon and text */
      align-items: center; /* Align icon and text */
      gap: 0.4rem; /* Space between icon and text */
    }
    .form-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .button-primary {
      background-color: #2563eb; /* blue-600 */
      color: #ffffff;
      border-color: #2563eb;
    }
    .button-primary:hover:not(:disabled) {
      background-color: #1d4ed8; /* blue-700 */
      border-color: #1d4ed8;
    }
    .button-secondary {
      background-color: #ffffff;
      color: #374151;
      border: 1px solid #d1d5db; /* gray-300 */
    }
    .button-secondary:hover:not(:disabled) {
      background-color: #f3f4f6; /* gray-100 */
      border-color: #adb5bd; /* gray-400 */
    }
    .button-success {
      background-color: #16a34a; /* green-600 */
      color: white;
      border: 1px solid transparent;
      border-color: #16a34a;
    }
    .button-success:hover:not(:disabled) {
      background-color: #15803d; /* green-700 */
      border-color: #15803d;
    }
    .button-warning {
      background-color: #f59e0b;
      color: white;
      border: 1px solid transparent;
    }
    .button-warning:hover:not(:disabled) {
      background-color: #d97706;
    }
    .button-danger {
      background-color: #dc2626; /* red-600 */
      color: white;
      border: 1px solid transparent;
      border-color: #dc2626;
    }
    .button-danger:hover:not(:disabled) {
      background-color: #b91c1c; /* red-700 */
      border-color: #b91c1c;
    }
    #scriptInput,
    #exportScriptArea {
      height: 220px; /* Increase height */
      font-family: "Courier New", Courier, monospace;
      font-size: 0.85rem; /* Increased from 0.8rem */
    }
    #exportScriptArea {
      background-color: #f9fafb;
      transition: background-color 0.3s ease; /* Added transition */
    }

    #introModal .modal-content {
      position: relative;
      overflow: hidden;
      z-index: 0;
    }
    #introModal .modal-content::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -1;
      background: linear-gradient(
        135deg,
        hsl(180, 80%, 80%),
        hsl(240, 80%, 85%),
        hsl(300, 80%, 80%),
        hsl(0, 80%, 85%),
        hsl(60, 80%, 80%),
        hsl(120, 80%, 85%)
      );
      background-size: 600% 600%;
      opacity: 0.6;
      animation: animatedGradientBackground 20s ease infinite;
    }
    @keyframes animatedGradientBackground {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }
    canvas.visualizing {
      /* Add a border to the canvas during visualization */
      border: 2px solid #a855f7; /* purple-500 */
      box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.3); /* Subtle outer glow */
    }
    /* Hide normal controls, show viz controls when visualizing */
    .visualization-control { display: none; }
    body.visualizing .normal-control { display: none; }
    body.visualizing .visualization-control { display: inline-flex; align-items: center; gap: 0.4rem; } /* Use flex for viz controls too */
    /* Ensure the span before viz controls is also hidden/shown correctly */
    body.visualizing #buttonContainer > span.visualization-control { display: block; } /* Use block for vertical layout */
    #buttonContainer > span.visualization-control { display: none; }

    /* Ensure about modal list items have proper spacing */
    #aboutModal ul li {
        margin-bottom: 4px;
    }
    #aboutModal code {
        font-size: 0.9em; /* Increased from 0.85em */
        padding: 2px 4px;
        background-color: #e5e7eb; /* gray-200 */
        border-radius: 3px;
        transition: background-color 0.3s ease, color 0.3s ease; /* Added transition */
    }
    /* Style for disabled toolbar buttons */
    .normal-control:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background-color: #e5e7eb !important; /* Use important to override hover styles */
        border-color: #d1d5db !important;
        color: #6b7280 !important;
    }
    /* Icon spacing for top bar buttons */
    .top-bar button i {
        margin-right: 0.3rem;
    }
    /* Specific icon adjustments if needed */
    .top-bar button#clearSelection i {
        margin-right: 0.2rem; /* Slightly less for smaller icon */
    }
    #introModal .space-y-3,
    #aboutModal .space-y-3 {
        font-size: 0.95rem; /* Increased from text-sm (0.875rem) */
    }
    .modal-content h2 { /* Target h2 specifically within modal-content */
        font-size: 1.25rem; /* Increased from text-lg/xl */
        margin-bottom: 1rem; /* Increased margin */
        transition: color 0.3s ease; /* Added transition */
    }

    /* --- Dark Mode Styles --- */
    body.dark {
      background-color: #111827; /* gray-900 */
      color: #d1d5db; /* gray-300 */
    }
    body.dark .main-container {
      background-color: #1f2937; /* gray-800 */
    }
    body.dark .left-panel {
      background-color: #374151; /* gray-700 */
      border-color: #4b5563; /* gray-600 */
      color: #f3f4f6; /* gray-100 */
    }
    body.dark .canvas-container {
      background-color: #111827; /* gray-900 */
      border-color: #4b5563; /* gray-600 */
    }
    body.dark .log-container {
      background-color: #374151; /* gray-700 */
      border-color: #4b5563; /* gray-600 */
      color: #e5e7eb; /* gray-200 */
    }
    body.dark .log-entry time {
      color: #9ca3af; /* gray-400 */
    }
    /* Dark mode log level adjustments */
    body.dark .log-info { background-color: #0c4a6e; border-color: #38bdf8; color: #e0f2fe; } /* sky-800 bg, sky-400 border, sky-100 text */
    body.dark .log-success { background-color: #166534; border-color: #4ade80; color: #dcfce7; } /* green-800 bg, green-400 border, green-100 text */
    body.dark .log-warn { background-color: #854d0e; border-color: #facc15; color: #fef9c3; } /* yellow-800 bg, yellow-400 border, yellow-100 text */
    body.dark .log-error { background-color: #991b1b; border-color: #f87171; color: #fee2e2; } /* red-800 bg, red-400 border, red-100 text */
    body.dark .log-viz { background-color: #581c87; border-color: #c084fc; color: #f3e8ff; } /* purple-800 bg, purple-400 border, purple-100 text */
    body.dark .log-viz-step { background-color: #4c1d95; border-color: #a78bfa; color: #ede9fe; } /* violet-800 bg, violet-400 border, violet-100 text */
    body.dark .log-viz-result { background-color: #115e59; border-color: #5eead4; color: #ccfbf1; } /* teal-800 bg, teal-400 border, teal-100 text */
    body.dark .log-deadlock { background-color: #b91c1c; border-color: #ef4444; color: #fecaca; } /* red-700 bg, red-500 border, red-200 text */

    body.dark .modal-content {
      background-color: #4b5563; /* gray-600 */
      border-color: #6b7280; /* gray-500 */
      color: #f3f4f6; /* gray-100 */
    }
     body.dark .modal-content h2 {
        color: #f9fafb; /* gray-50 */
     }
    body.dark .modal-close-button {
      color: #d1d5db; /* gray-300 */
    }
    body.dark .modal-close-button:hover,
    body.dark .modal-close-button:focus {
      color: #f9fafb; /* gray-50 */
    }
    body.dark .form-input {
      background-color: #374151; /* gray-700 */
      border-color: #6b7280; /* gray-500 */
      color: #f3f4f6; /* gray-100 */
    }
    body.dark .form-input::placeholder {
        color: #9ca3af; /* gray-400 */
    }
    body.dark .form-input:focus {
      border-color: #60a5fa; /* blue-400 */
      box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5); /* Ring effect */
    }
    body.dark .form-input[readonly] {
      background-color: #4b5563; /* gray-600 */
    }
    body.dark .form-label {
      color: #d1d5db; /* gray-300 */
    }
    body.dark #exportScriptArea {
      background-color: #1f2937; /* gray-800 */
    }
    body.dark #aboutModal code {
        background-color: #374151; /* gray-700 */
        color: #e5e7eb; /* gray-200 */
    }
    body.dark .top-bar button { /* Adjust default button colors */
        background-color: #4b5563; /* gray-600 */
        border-color: #6b7280; /* gray-500 */
        color: #f3f4f6; /* gray-100 */
    }
    body.dark .top-bar button:hover:not(:disabled) {
        background-color: #52525b; /* zinc-600 */
        border-color: #71717a; /* zinc-500 */
    }
    /* Override specific button types for dark mode */
    body.dark .top-bar button#addProcessBtn { background-color: #075985; border-color: #38bdf8; color: #e0f2fe; } /* sky-800 */
    body.dark .top-bar button#addProcessBtn:hover:not(:disabled) { background-color: #0369a1; border-color: #7dd3fc; } /* sky-700 */
    body.dark .top-bar button#addResourceBtn { background-color: #9a3412; border-color: #fb923c; color: #ffedd5; } /* orange-800 */
    body.dark .top-bar button#addResourceBtn:hover:not(:disabled) { background-color: #c2410c; border-color: #fdba74; } /* orange-700 */
    body.dark .top-bar button#requestEdge { background-color: #991b1b; border-color: #f87171; color: #fee2e2; } /* red-800 */
    body.dark .top-bar button#requestEdge:hover:not(:disabled) { background-color: #b91c1c; border-color: #fca5a5; } /* red-700 */
    body.dark .top-bar button#assignEdge { background-color: #166534; border-color: #4ade80; color: #dcfce7; } /* green-800 */
    body.dark .top-bar button#assignEdge:hover:not(:disabled) { background-color: #15803d; border-color: #86efac; } /* green-700 */
    body.dark .top-bar button#releaseResourceBtn { background-color: #854d0e; border-color: #facc15; color: #fef9c3; } /* yellow-800 */
    body.dark .top-bar button#releaseResourceBtn:hover:not(:disabled) { background-color: #a16207; border-color: #fde047; } /* yellow-700 */
    body.dark .top-bar button#editNodeBtn { background-color: #1e40af; border-color: #60a5fa; color: #dbeafe; } /* blue-800 */
    body.dark .top-bar button#editNodeBtn:hover:not(:disabled) { background-color: #1e3a8a; border-color: #93c5fd; } /* blue-700 */
    body.dark .top-bar button#visualizeDeadlockBtn { background-color: #581c87; border-color: #c084fc; color: #f3e8ff; } /* purple-800 */
    body.dark .top-bar button#visualizeDeadlockBtn:hover:not(:disabled) { background-color: #6b21a8; border-color: #d8b4fe; } /* purple-700 */
    body.dark .top-bar button#directDeadlockBtn { background-color: #6b21a8; border-color: #a855f7; color: #e9d5ff; } /* purple-700 */
    body.dark .top-bar button#directDeadlockBtn:hover:not(:disabled) { background-color: #7e22ce; border-color: #c084fc; } /* purple-600 */
    body.dark .top-bar button#scriptButton { background-color: #115e59; border-color: #5eead4; color: #ccfbf1; } /* teal-800 */
    body.dark .top-bar button#scriptButton:hover:not(:disabled) { background-color: #134e4a; border-color: #99f6e4; } /* teal-700 */
    body.dark .top-bar button#exportScriptButton { background-color: #155e75; border-color: #67e8f9; color: #cffafe; } /* cyan-800 */
    body.dark .top-bar button#exportScriptButton:hover:not(:disabled) { background-color: #164e63; border-color: #a5f3fc; } /* cyan-700 */
    body.dark .top-bar button#clearAllButton { background-color: #b91c1c; border-color: #ef4444; color: #fecaca; } /* red-700 */
    body.dark .top-bar button#clearAllButton:hover:not(:disabled) { background-color: #991b1b; border-color: #f87171; } /* red-800 */
    body.dark .top-bar button#aboutButton { background-color: #3730a3; border-color: #818cf8; color: #e0e7ff; } /* indigo-800 */
    body.dark .top-bar button#aboutButton:hover:not(:disabled) { background-color: #4338ca; border-color: #a5b4fc; } /* indigo-700 */
    body.dark .top-bar button#darkModeToggle { background-color: #1f2937; border-color: #4b5563; color: #fde047; } /* gray-800 bg, yellow text */
    body.dark .top-bar button#darkModeToggle:hover:not(:disabled) { background-color: #111827; border-color: #6b7280; } /* gray-900 bg */

    body.dark .normal-control:disabled {
        opacity: 0.4;
        background-color: #4b5563 !important;
        border-color: #6b7280 !important;
        color: #cecece !important;
    }
    body.dark .visualization-control { color: #d8b4fe; } /* purple-300 */

    /* Dark mode modal buttons */
    body.dark .button-primary { background-color: #3b82f6; color: #ffffff; border-color: #3b82f6; } /* blue-500 */
    body.dark .button-primary:hover:not(:disabled) { background-color: #2563eb; border-color: #2563eb; } /* blue-600 */
    body.dark .button-secondary { background-color: #4b5563; color: #f3f4f6; border-color: #6b7280; } /* gray-600 */
    body.dark .button-secondary:hover:not(:disabled) { background-color: #52525b; border-color: #71717a; } /* zinc-600 */
    body.dark .button-success { background-color: #22c55e; color: #ffffff; border-color: #22c55e; } /* green-500 */
    body.dark .button-success:hover:not(:disabled) { background-color: #16a34a; border-color: #16a34a; } /* green-600 */
    body.dark .button-danger { background-color: #ef4444; color: #ffffff; border-color: #ef4444; } /* red-500 */
    body.dark .button-danger:hover:not(:disabled) { background-color: #dc2626; border-color: #dc2626; } /* red-600 */

  </style>
</head>

<body class="font-mono"> <!-- Removed initial class, JS will add light/dark -->

  <!-- Intro Modal -->
  <div id="introModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeIntroModal()">×</span>
      <h2 class="text-xl font-semibold mb-4 text-gray-800">Welcome to the RAG Simulator!</h2>
      <div class="space-y-3 text-gray-700 text-sm mb-4">
        <p>This tool helps you visualize Resource Allocation Graphs and detect deadlocks.</p>
        <p>
          Use the buttons in the top bar to add Processes (circles) and Resources (squares),
          create request/assignment edges, and visualize the deadlock detection algorithm step-by-step.
        </p>
        <p>Check the "About" section for detailed features and shortcuts.</p>
      </div>
      <div class="flex items-center justify-between mt-5">
        <div class="flex items-center">
          <input id="dontShowIntroAgain" type="checkbox"
            class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
          <label for="dontShowIntroAgain" class="ml-2 block text-sm text-gray-900">Don't show this again</label>
        </div>
        <button class="form-button button-primary" onclick="closeIntroModal()"><i class="fa-solid fa-play"></i>Get Started</button>
      </div>
    </div>
  </div>

  <!-- Main Layout -->
  <div class="main-container">

    <!-- Left Panel (Was Top Control Bar) -->
    <div class="left-panel">
      <div class="top-bar">
        <div id="buttonContainer"> <!-- Removed flex classes, handled by CSS -->
          <!-- Normal Controls -->
          <button id="addProcessBtn" title="Shortcut: P"
            class="normal-control py-1 px-3 border border-blue-300 bg-blue-100 hover:bg-blue-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-circle-plus"></i>Add Process
          </button>
          <button id="addResourceBtn" title="Shortcut: R"
            class="normal-control py-1 px-3 border border-orange-300 bg-orange-100 hover:bg-orange-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-square-plus"></i>Add Resource
          </button>
          <button id="requestEdge" title="Shortcut: Q"
            class="normal-control py-1 px-3 border border-red-300 bg-red-100 hover:bg-red-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5" disabled>
            <i class="fa-solid fa-arrow-right-long"></i>Make Request (P->R)
          </button>
          <button id="assignEdge" title="Shortcut: A"
            class="normal-control py-1 px-3 border border-green-400 bg-green-100 hover:bg-green-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5" disabled>
            <i class="fa-solid fa-arrow-left-long"></i>Make Assignment (R->P)
          </button>
          <button id="releaseResourceBtn" title="Shortcut: L"
            class="normal-control py-1 px-3 border border-yellow-400 bg-yellow-100 hover:bg-yellow-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5" disabled>
            <i class="fa-solid fa-arrow-right-from-bracket"></i>Release Resource (R<-P)
          </button>
          <button id="removeEdge"
            class="normal-control py-1 px-3 border border-gray-300 bg-white hover:bg-gray-100 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5" disabled>
            <i class="fa-solid fa-link-slash"></i>Remove Edge
          </button>
          <button id="removeNode" title="Shortcut: Delete/Backspace/X"
            class="normal-control py-1 px-3 border border-gray-300 bg-white hover:bg-gray-100 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5" disabled>
            <i class="fa-solid fa-trash-can"></i>Remove Node
          </button>
          <button id="editNodeBtn" title="Shortcut: M"
            class="normal-control py-1 px-3 border border-blue-400 bg-blue-200 hover:bg-blue-300 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5" disabled>
            <i class="fa-solid fa-pencil"></i>Edit Node
          </button>
          <button id="visualizeDeadlockBtn" title="Visualize Deadlock Detection (Step-by-step) (D)"
            class="normal-control py-1 px-3 border border-purple-300 bg-purple-100 hover:bg-purple-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-person-walking-arrow-loop-left"></i>Visualize Deadlock
          </button>
           <button id="directDeadlockBtn" title="Detect Deadlock Now (K)"
            class="normal-control py-1 px-3 border border-purple-400 bg-purple-200 hover:bg-purple-300 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-magnifying-glass"></i>Detect Now
          </button>
          <button id="clearSelection" title="Shortcut: Escape"
            class="normal-control py-1 px-3 border border-gray-300 bg-white hover:bg-gray-100 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-xmark"></i>Clear Selection
          </button>
          <button id="scriptButton" title="Run commands"
            class="normal-control py-1 px-3 border border-teal-300 bg-teal-100 hover:bg-teal-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-scroll"></i>Script
          </button>
          <button id="exportScriptButton" title="Export current graph as script (E)"
            class="normal-control py-1 px-3 border border-cyan-300 bg-cyan-100 hover:bg-cyan-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-file-export"></i>Export Script
          </button>
          <button id="aiGenerateBtn" title="Generate graph from text (G)"
            class="normal-control py-1 px-3 border border-pink-300 bg-pink-100 hover:bg-pink-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-wand-magic-sparkles"></i>Generate (AI)
          </button>
          <button id="clearAllButton" title="Shortcut: C"
            class="normal-control py-1 px-3 border border-red-400 bg-red-200 hover:bg-red-300 rounded shadow-sm text-sm font-semibold transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-eraser"></i>Clear All
          </button>
          <button id="aboutButton"
            class="normal-control py-1 px-3 border border-indigo-300 bg-indigo-100 hover:bg-indigo-200 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-circle-info"></i>About
          </button>
          <button id="darkModeToggle" title="Toggle Dark/Light Mode (T)"
            class="normal-control py-1 px-3 border border-gray-400 bg-gray-200 hover:bg-gray-300 rounded shadow-sm text-sm transition-colors duration-150 inline-flex items-center gap-1.5">
            <i class="fa-solid fa-moon"></i>Dark Mode
          </button>

          <!-- Visualization Controls -->
          <span class="visualization-control text-sm font-semibold text-purple-700 mr-2">Deadlock Visualization:</span>
          <button id="stepDeadlockVizBtn" title="Execute next detection step (Space)"
            class="visualization-control form-button button-primary py-1 px-3 text-sm">
            <i class="fa-solid fa-forward-step"></i>Step ▶
          </button>
          <button id="runDeadlockVizBtn" title="Run detection to end (R)"
            class="visualization-control form-button button-success py-1 px-3 text-sm">
            <i class="fa-solid fa-forward-fast"></i>Run to End ▶▶
          </button>
          <button id="stopDeadlockVizBtn" title="Stop visualization (Esc)"
            class="visualization-control form-button button-danger py-1 px-3 text-sm">
            <i class="fa-solid fa-stop"></i>Stop Viz ⏹
          </button>
        </div>
      </div>
    </div>

    <!-- Right Area (Canvas + Log) -->
    <div class="right-area">
      <!-- Canvas Area -->
      <div class="canvas-container">
        <canvas id="ragCanvas"></canvas>
      </div>

      <!-- Log Area -->
      <div id="logContainer" class="log-container"></div>
    </div>

  </div>

  <!-- Add Process Modal -->
  <div id="addProcessModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('addProcessModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800">
        <i class="fa-solid fa-circle-plus text-blue-500 mr-2"></i>Add New Process
      </h2>
      <label for="processIdInput" class="form-label">Process ID (Optional):</label>
      <input type="text" id="processIdInput" class="form-input" placeholder="e.g., P1 (auto-generated if blank)" />
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('addProcessModal')">
          <i class="fa-solid fa-xmark"></i>Cancel</button>
        <button class="form-button button-primary" onclick="submitAddProcess()">
          <i class="fa-solid fa-plus"></i>Add Process
        </button>
      </div>
    </div>
  </div>

  <!-- Add Resource Modal -->
  <div id="addResourceModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('addResourceModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800">
        <i class="fa-solid fa-square-plus text-orange-500 mr-2"></i>Add New Resource
      </h2>
      <label for="resourceIdInput" class="form-label">Resource ID (Optional):</label>
      <input type="text" id="resourceIdInput" class="form-input" placeholder="e.g., R1 (auto-generated if blank)" />
      <label for="resourceInstancesInput" class="form-label">Number of Instances:</label>
      <input type="number" id="resourceInstancesInput" class="form-input" value="1" min="1" max="100" />
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('addResourceModal')">
          <i class="fa-solid fa-xmark"></i>Cancel</button>
        <button class="form-button button-primary" onclick="submitAddResource()">
          <i class="fa-solid fa-plus"></i>Add Resource
        </button>
      </div>
    </div>
  </div>

  <!-- Edit Process Modal -->
  <div id="editProcessModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('editProcessModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800">
        <i class="fa-solid fa-pencil text-blue-500 mr-2"></i>Edit Process
      </h2>
      <input type="hidden" id="editProcessOriginalId"> <!-- Store original ID -->
      <label for="editProcessIdInput" class="form-label">Process ID:</label>
      <input type="text" id="editProcessIdInput" class="form-input"/>
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('editProcessModal')">
          <i class="fa-solid fa-xmark"></i>Cancel</button>
        <button class="form-button button-primary" onclick="submitEditProcess()">
          <i class="fa-solid fa-floppy-disk"></i>Save Changes
        </button>
      </div>
    </div>
  </div>

  <!-- Edit Resource Modal -->
  <div id="editResourceModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('editResourceModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800">
        <i class="fa-solid fa-pencil text-orange-500 mr-2"></i>Edit Resource
      </h2>
      <input type="hidden" id="editResourceOriginalId"> <!-- Store original ID -->
      <label for="editResourceIdInput" class="form-label">Resource ID:</label>
      <input type="text" id="editResourceIdInput" class="form-input" />
      <label for="editResourceInstancesInput" class="form-label">Number of Instances:</label>
      <input type="number" id="editResourceInstancesInput" class="form-input" value="1" min="1" max="100" />
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('editResourceModal')">
          <i class="fa-solid fa-xmark"></i>Cancel</button>
        <button class="form-button button-primary" onclick="submitEditResource()">
          <i class="fa-solid fa-floppy-disk"></i>Save Changes
        </button>
      </div>
    </div>
  </div>


  <!-- Script Modal -->
  <div id="scriptModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('scriptModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800"><i class="fa-solid fa-scroll text-teal-600 mr-2"></i>Run Script</h2>
      <p class="text-sm mb-3">
        Enter commands separated by semicolons (;) or newlines.<br />
        Use <code class="text-xs bg-gray-100 p-1 rounded">//</code> for comments.
      </p>
      <label for="scriptInput" class="form-label">Commands:</label>
      <textarea id="scriptInput" class="form-input" placeholder="e.g., ADD P P1; // Add process
ADD R R1 2;
REQ P1 R1;"></textarea>
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('scriptModal')">
          <i class="fa-solid fa-xmark"></i>Cancel
        </button>
        <button class="form-button button-primary" onclick="runScript()">
          <i class="fa-solid fa-play"></i>Run All
        </button>
      </div>
    </div>
  </div>

  <!-- Export Script Modal -->
  <div id="exportModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('exportModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800">
        <i class="fa-solid fa-file-export text-cyan-600 mr-2"></i>Export Graph Script
      </h2>
      <p class="text-sm mb-3">
        Copy the script below to recreate the current graph state.
      </p>
      <label for="exportScriptArea" class="form-label">Generated Script:</label>
      <textarea id="exportScriptArea" class="form-input" readonly></textarea>
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('exportModal')">
          <i class="fa-solid fa-xmark"></i>Close
        </button>
        <button id="copyScriptButton" class="form-button button-primary">
          <i class="fa-solid fa-clipboard"></i>Copy to Clipboard
        </button>
      </div>
    </div>
  </div>

  <!-- About Modal -->
  <div id="aboutModal" class="modal">
      <div class="modal-content">
        <span class="modal-close-button" onclick="closeModal('aboutModal')">×</span>
        <h2 class="text-xl font-semibold mb-4">
          <i class="fa-solid fa-circle-info text-indigo-500 mr-2"></i>About RAG Simulator v2.3
        </h2>
        <div class="space-y-3 text-sm">
          <p>A simulator for visualizing Resource Allocation Graphs (RAGs).</p>
          <p class="text-center font-bold">
            Made by: <a href="https://github.com/JhaAnurag">Anurag,</a> Amit, Himanshu
          </p>
          <div>
            <h3 class="font-semibold mb-1">Features & Shortcuts:</h3>
            <ul class="list-disc pl-5 space-y-1">
              <li>
                Add Process (<code class="bg-gray-200 px-1 rounded">P</code>) &
                Resource (<code class="bg-gray-200 px-1 rounded">R</code>).
              </li>
               <li>Click nodes to select (up to two). Drag to reposition.</li>
               <li>Edit selected node (<code class="bg-gray-200 px-1 rounded">M</code>, requires single selection). Allows changing ID and Resource instances.</li>
              <li>
                Create Request (<code class="bg-gray-200 px-1 rounded">Q</code>, P->R)
                or Assignment (<code class="bg-gray-200 px-1 rounded">A</code>, R->P)
                edges (requires P & R selected). Assignments check availability.
              </li>
              <li>
                Release Resource (<code class="bg-gray-200 px-1 rounded">L</code>): Removes R->P edge (requires R & P selected).
              </li>
              <li>
                Remove selected node (<code class="bg-gray-200 px-1 rounded">Del/Bksp/X</code>, requires single selection) or edge (button, requires two nodes selected).
              </li>
              <li>
                Detect Deadlock directly (<code class="bg-gray-200 px-1 rounded">K</code>) - Highlights all involved nodes (purple).
              </li>
              <li>
                Visualize Deadlock (<code class="bg-gray-200 px-1 rounded">D</code>) step-by-step. Finds all cycles.
              </li>
              <li>
                Step forward (<code class="bg-gray-200 px-1 rounded">Space</code>) / Run to End (<code class="bg-gray-200 px-1 rounded">R</code>) / Stop (<code class="bg-gray-200 px-1 rounded">Esc</code>) during visualization.
              </li>
              <li>
                Clear selection (<code class="bg-gray-200 px-1 rounded">Esc</code>
                in normal mode).
              </li>
              <li>
                Run graph creation scripts (Script button). Supports
                <code class="bg-gray-200 px-1 rounded">ADD</code>, <code class="bg-gray-200 px-1 rounded">REQ</code>, <code class="bg-gray-200 px-1 rounded">ASSIGN</code>, <code class="bg-gray-200 px-1 rounded">RELEASE</code>, <code class="bg-gray-200 px-1 rounded">REMOVE</code>, <code class="bg-gray-200 px-1 rounded">CLEAR</code>, and <code class="bg-gray-200 px-1 rounded">//</code> comments.
              </li>
              <li>
                Export current graph to script (<code class="bg-gray-200 px-1 rounded">E</code>).
              </li>
              <li>
                Clear canvas (<code class="bg-gray-200 px-1 rounded">C</code>,
                confirms first).
              </li>
              <li>Detailed Log panel with color coding.</li>
              <li>Resizable canvas, selected edge highlight, assignment animation.</li>
            </ul>
          </div>
          <p class="text-xs text-gray-500 mt-4">
            Version: 2.3-SingleFile-Final<br />
            Based on: <a href="https://github.com/JhaAnurag/OSproject" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">GitHub Project</a>
          </p>
        </div>
      </div>
    </div>

  <!-- AI Generate Modal -->
  <div id="aiGenerateModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-button" onclick="closeModal('aiGenerateModal')">×</span>
      <h2 class="text-lg font-semibold mb-4 text-gray-800">
        <i class="fa-solid fa-wand-magic-sparkles text-pink-500 mr-2"></i>Generate Graph with AI
      </h2>
      <p class="text-sm mb-3">
        Describe the processes, resources, requests, and assignments in natural language.
        The AI will attempt to generate the corresponding script commands.
      </p>
      <label for="aiInput" class="form-label">Describe the graph:</label>
      <textarea id="aiInput" class="form-input" rows="5" placeholder="e.g., Create process P1 requesting resource R1. R1 has 2 instances and is also assigned to P2."></textarea>
      <div class="flex justify-end gap-2 mt-4">
        <button class="form-button button-secondary" onclick="closeModal('aiGenerateModal')">
          <i class="fa-solid fa-xmark"></i>Cancel
        </button>
        <button id="submitAiGenerateBtn" class="form-button button-primary" onclick="submitAiGenerate()">
          <i class="fa-solid fa-robot"></i>Generate
        </button>
      </div>
      <div id="aiErrorLog" class="text-red-600 text-sm mt-3" style="display: none;"></div>
    </div>
  </div>


  <!-- Embedded JavaScript -->
  <script>
    // --- DOM Element References ---
    const canvas = document.getElementById("ragCanvas");
    const ctx = canvas.getContext("2d");
    const logContainer = document.getElementById("logContainer");
    const bodyElement = document.body;

    // Buttons
    const addProcessBtn = document.getElementById("addProcessBtn");
    const addResourceBtn = document.getElementById("addResourceBtn");
    const requestEdgeBtn = document.getElementById("requestEdge");
    const assignEdgeBtn = document.getElementById("assignEdge");
    const releaseResourceBtn = document.getElementById("releaseResourceBtn");
    const removeEdgeBtn = document.getElementById("removeEdge");
    const removeNodeBtn = document.getElementById("removeNode");
    const editNodeBtn = document.getElementById("editNodeBtn"); // New Edit Button
    const visualizeDeadlockBtn = document.getElementById("visualizeDeadlockBtn");
    const directDeadlockBtn = document.getElementById("directDeadlockBtn");
    const clearSelectionBtn = document.getElementById("clearSelection");
    const scriptButton = document.getElementById("scriptButton");
    const exportScriptButton = document.getElementById("exportScriptButton");
    const clearAllButton = document.getElementById("clearAllButton");
    const aboutButton = document.getElementById("aboutButton");
    const darkModeToggle = document.getElementById("darkModeToggle"); // New Dark Mode Button
    const stepDeadlockVizBtn = document.getElementById("stepDeadlockVizBtn");
    const runDeadlockVizBtn = document.getElementById("runDeadlockVizBtn");
    const stopDeadlockVizBtn = document.getElementById("stopDeadlockVizBtn");
    const copyScriptButton = document.getElementById("copyScriptButton");
    const aiGenerateBtn = document.getElementById("aiGenerateBtn"); // New AI Button
    // Modals
    const introModal = document.getElementById("introModal");
    const addProcessModal = document.getElementById("addProcessModal");
    const addResourceModal = document.getElementById("addResourceModal");
    const editProcessModal = document.getElementById("editProcessModal"); // New Edit Modal
    const editResourceModal = document.getElementById("editResourceModal"); // New Edit Modal
    const scriptModal = document.getElementById("scriptModal");
    const exportModal = document.getElementById("exportModal");
    const aboutModal = document.getElementById("aboutModal");
    const aiGenerateModal = document.getElementById("aiGenerateModal"); // New AI Modal

    // Modal Inputs
    const processIdInput = document.getElementById("processIdInput");
    const resourceIdInput = document.getElementById("resourceIdInput");
    const resourceInstancesInput = document.getElementById("resourceInstancesInput");
    const editProcessIdInput = document.getElementById("editProcessIdInput"); // New Input
    const editProcessOriginalIdInput = document.getElementById("editProcessOriginalId"); // Hidden Input
    const editResourceIdInput = document.getElementById("editResourceIdInput"); // New Input
    const editResourceInstancesInput = document.getElementById("editResourceInstancesInput"); // New Input
    const editResourceOriginalIdInput = document.getElementById("editResourceOriginalId"); // Hidden Input
    const scriptInput = document.getElementById("scriptInput");
    const exportScriptArea = document.getElementById("exportScriptArea");
    const aiInput = document.getElementById("aiInput"); // New AI Input
    const submitAiGenerateBtn = document.getElementById("submitAiGenerateBtn"); // New AI Submit Button
    const aiErrorLog = document.getElementById("aiErrorLog"); // New AI Error Display


    // --- Constants ---
    const PROCESS_COLOR = "#bae6fd"; // sky-200
    const RESOURCE_COLOR = "#fed7aa"; // orange-200
    const REQUEST_EDGE_COLOR = "#ef4444"; // red-500
    const ASSIGN_EDGE_COLOR = "#22c55e"; // green-500
    const NODE_SELECTED_COLOR = "#facc15"; // yellow-400 (Selection Stroke)
    const DEADLOCK_HIGHLIGHT_COLOR = "#a855f7"; // purple-500 (Deadlock Stroke/Edge)
    const EDGE_SELECTED_HIGHLIGHT_COLOR = "#fbbf24"; // amber-400 (Selected Edge)
    const NODE_STROKE_COLOR = "#1f2937"; // gray-800
    const TEXT_COLOR = "#1f2937"; // gray-800
    const INSTANCE_TEXT_COLOR = "#374151"; // gray-700
    // Dark Mode Colors
    const DARK_PROCESS_COLOR = "#0c4a6e"; // sky-800
    const DARK_RESOURCE_COLOR = "#9a3412"; // orange-800
    const DARK_NODE_STROKE_COLOR = "#d1d5db"; // gray-300
    const DARK_TEXT_COLOR = "#f3f4f6"; // gray-100
    const DARK_INSTANCE_TEXT_COLOR = "#9ca3af"; // gray-400
    const DARK_REQUEST_EDGE_COLOR = "#f87171"; // red-400
    const DARK_ASSIGN_EDGE_COLOR = "#4ade80"; // green-400
    const DARK_NODE_SELECTED_COLOR = "#fde047"; // yellow-300
    const DARK_DEADLOCK_HIGHLIGHT_COLOR = "#c084fc"; // purple-400
    const DARK_EDGE_SELECTED_HIGHLIGHT_COLOR = "#fcd34d"; // amber-300

    const HIGHLIGHTED_EDGE_WIDTH = 3;
    const NORMAL_EDGE_WIDTH = 2;
    const PROCESS_RADIUS = 31;
    const RESOURCE_SIZE = 55;
    const RESOURCE_TEXT_FONT_SIZE = 13;
    const ARROW_SIZE = 8;
    const GAP = 5;
    const ANIMATION_DURATION = 500;
    const MAX_LOG_ENTRIES = 150;
    const ASSIGNMENT_ANIMATION_SPEED = 2000;
    const ANIMATION_DOT_SIZE = 4;

    // --- State Variables ---
    let nodes = [];
    let edges = [];
    let logs = [];
    let processCounter = 0; // Used for auto-generating IDs
    let resourceCounter = 0; // Used for auto-generating IDs
    let selectedNode1 = null;
    let selectedNode2 = null;
    let draggingNode = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let animationFrameId = null;
    let activeModal = null;

    let deadlockedNodes = new Set();
    let isVisualizingDeadlock = false;
    let deadlockVizState = null;
    let deadlockVizGeneratorInstance = null;
    let isDarkMode = false; // Track dark mode state

    // --- Modal Functions ---
    function openModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        // Pre-population and focus logic
        if (modalId === "addProcessModal") {
          let nextPId = 1;
          while(findNodeById(`P${nextPId}`)) { nextPId++; }
          processIdInput.value = "";
          processIdInput.placeholder = `e.g., P${nextPId} (auto-generated)`;
          processIdInput.focus();
        } else if (modalId === "addResourceModal") {
           let nextRId = 1;
          while(findNodeById(`R${nextRId}`)) { nextRId++; }
          resourceIdInput.value = "";
          resourceIdInput.placeholder = `e.g., R${nextRId} (auto-generated)`;
          resourceInstancesInput.value = "1";
          resourceIdInput.focus();
        } else if (modalId === "editProcessModal" && selectedNode1) {
            editProcessIdInput.value = selectedNode1.id;
            editProcessOriginalIdInput.value = selectedNode1.id; // Store original ID
            editProcessIdInput.focus();
        } else if (modalId === "editResourceModal" && selectedNode1) {
            editResourceIdInput.value = selectedNode1.id;
            editResourceInstancesInput.value = selectedNode1.totalInstances;
            editResourceOriginalIdInput.value = selectedNode1.id; // Store original ID
            editResourceIdInput.focus();
        } else if (modalId === "exportModal") {
          exportScriptArea.value = generateScript();
          exportScriptArea.scrollTop = 0;
          copyScriptButton.textContent = "Copy to Clipboard";
        } else if (modalId === 'scriptModal') {
            scriptInput.focus();
        } else if (modalId === 'aiGenerateModal') { // New AI Modal Logic
            aiInput.value = ''; // Clear previous input
            aiErrorLog.style.display = 'none'; // Hide previous errors
            aiErrorLog.textContent = '';
            submitAiGenerateBtn.disabled = false; // Ensure button is enabled
            submitAiGenerateBtn.innerHTML = '<i class="fa-solid fa-robot"></i> Generate';
            aiInput.focus();
        }
        modal.style.display = "flex";
        activeModal = modalId;
        ensureAnimationLoop(); // Keep drawing background if needed
      } else {
        console.error("Modal not found:", modalId);
      }
    }

    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = "none";
        if (activeModal === modalId) {
            activeModal = null; // Clear active modal state
        }
        // Reset AI modal button state if closing it
        if (modalId === 'aiGenerateModal') {
            submitAiGenerateBtn.disabled = false;
            submitAiGenerateBtn.innerHTML = '<i class="fa-solid fa-robot"></i> Generate';
            aiErrorLog.style.display = 'none';
        }
        ensureAnimationLoop(); // Redraw canvas once after closing
      }
    }

    function closeIntroModal() {
      const dontShowCheckbox = document.getElementById("dontShowIntroAgain");
      if (dontShowCheckbox && dontShowCheckbox.checked) {
        try {
          localStorage.setItem("ragIntroShown", "true");
          logMessage("INFO", "Introduction modal won't be shown again.");
        } catch (e) {
          console.error("LocalStorage not available or failed:", e);
          logMessage(
            "WARN",
            "Could not save 'don't show again' preference (LocalStorage might be disabled)."
          );
        }
      }
      closeModal("introModal");
    }

    // Close modal if clicking outside the content area
    window.addEventListener("click", (event) => {
      if (activeModal && event.target.classList.contains("modal")) {
        closeModal(activeModal);
      }
    });

    // --- Logging ---
    function logMessage(level, message, isStep = false) {
      const timestamp = new Date().toLocaleTimeString([], { hour12: false });
      const upperLevel = level.toUpperCase();
      const entry = { timestamp, level: upperLevel, message, isStep };
      logs.push(entry);
      if (logs.length > MAX_LOG_ENTRIES) {
        logs.shift();
      }
      renderLogs();
    }

    function renderLogs() {
      logContainer.innerHTML = "";
      logs.forEach((entry) => {
        const div = document.createElement("div");
        div.className = "log-entry";
        let levelClass = `log-${entry.level.toLowerCase().replace(/_/g, '-')}`;
        if (entry.isStep) { levelClass = 'log-viz-step'; }
        div.classList.add(levelClass);
        div.innerHTML = `<time>${entry.timestamp}</time> <span>${entry.message}</span>`;
        logContainer.appendChild(div);
      });
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // --- Canvas Utilities ---
    function getMousePos(canvasEl, evt) {
      const rect = canvasEl.getBoundingClientRect();
      const scaleX = canvasEl.width / rect.width;
      const scaleY = canvasEl.height / rect.height;
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY,
      };
    }

    function isPointInNode(node, x, y) {
      const scale = node.currentScale ?? 1.0;
      if (node.type === "process") {
        const dx = x - node.x;
        const dy = y - node.y;
        return dx * dx + dy * dy <= Math.pow(PROCESS_RADIUS * scale, 2);
      } else {
        const halfSize = (RESOURCE_SIZE / 2) * scale;
        return (x >= node.x - halfSize && x <= node.x + halfSize && y >= node.y - halfSize && y <= node.y + halfSize);
      }
    }

    function getNodeAtPos(x, y) {
      for (let i = nodes.length - 1; i >= 0; i--) {
        if (isPointInNode(nodes[i], x, y) && (!nodes[i].isAnimating || nodes[i].currentScale > 0.8)) {
          return nodes[i];
        }
      }
      return null;
    }

    function findNodeById(nodeId) {
         if (!nodeId) return null; // Handle null/empty IDs gracefully
         const upperId = nodeId.toUpperCase();
         return nodes.find((n) => n.id === upperId);
    }


    function getAssignedInstancesCount(resourceNodeId) {
        if (!resourceNodeId) return 0;
        return edges.filter(edge => edge.from === resourceNodeId && edge.type === 'assignment').length;
    }


    function getAvailableInstances(resourceNode) {
      if (!resourceNode || resourceNode.type !== "resource") return 0;
      const assignedCount = getAssignedInstancesCount(resourceNode.id);
      return resourceNode.totalInstances - assignedCount;
    }

    function getEdgePoints(node1, node2) {
      const dx = node2.x - node1.x;
      const dy = node2.y - node1.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const unitX = dist === 0 ? 0 : dx / dist;
      const unitY = dist === 0 ? 0 : dy / dist;
      const node1Scale = node1.currentScale ?? 1.0;
      const node2Scale = node2.currentScale ?? 1.0;
      const startOffsetBase = node1.type === "process" ? PROCESS_RADIUS * node1Scale : (RESOURCE_SIZE / 2) * node1Scale;
      const endOffsetBase = node2.type === "process" ? PROCESS_RADIUS * node2Scale : (RESOURCE_SIZE / 2) * node2Scale;
      let startX, startY, endX, endY;
      if (dist > startOffsetBase + endOffsetBase + GAP) {
           startX = node1.x + unitX * (startOffsetBase + GAP);
           startY = node1.y + unitY * (startOffsetBase + GAP);
           endX = node2.x - unitX * (endOffsetBase + GAP);
           endY = node2.y - unitY * (endOffsetBase + GAP);
      } else {
          startX = node1.x; startY = node1.y;
          endX = node2.x; endY = node2.y;
      }
      return { start: { x: startX, y: startY }, end: { x: endX, y: endY } };
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, lineWidth = NORMAL_EDGE_WIDTH) {
      if (Math.abs(fromX - toX) < 0.1 && Math.abs(fromY - toY) < 0.1) return;
      const headlen = ARROW_SIZE * (lineWidth / NORMAL_EDGE_WIDTH);
      const dx = toX - fromX;
      const dy = toY - fromY;
      const angle = Math.atan2(dy, dx);
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(toX, toY);
      ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }

    // --- Animation & Drawing ---
    function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
    function ensureAnimationLoop() { if (!animationFrameId) { animationFrameId = requestAnimationFrame(draw); } }

    function draw() {
      const dpr = window.devicePixelRatio || 1;
      const canvasWidth = canvas.clientWidth;
      const canvasHeight = canvas.clientHeight;
      if (canvas.width !== canvasWidth * dpr || canvas.height !== canvasHeight * dpr) {
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;
        ctx.scale(dpr, dpr);
      }
      ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Use clientWidth/Height for clearing

      const now = performance.now();
      let needsAnotherFrame = false;
      let hasAssignmentEdges = false;

      // Determine colors based on mode
      const currentTextColor = isDarkMode ? DARK_TEXT_COLOR : TEXT_COLOR;
      const currentInstanceTextColor = isDarkMode ? DARK_INSTANCE_TEXT_COLOR : INSTANCE_TEXT_COLOR;
      const currentStrokeColor = isDarkMode ? DARK_NODE_STROKE_COLOR : NODE_STROKE_COLOR;
      const currentRequestEdgeColor = isDarkMode ? DARK_REQUEST_EDGE_COLOR : REQUEST_EDGE_COLOR;
      const currentAssignEdgeColor = isDarkMode ? DARK_ASSIGN_EDGE_COLOR : ASSIGN_EDGE_COLOR;
      const currentSelectedEdgeColor = isDarkMode ? DARK_EDGE_SELECTED_HIGHLIGHT_COLOR : EDGE_SELECTED_HIGHLIGHT_COLOR;
      const currentDeadlockColor = isDarkMode ? DARK_DEADLOCK_HIGHLIGHT_COLOR : DEADLOCK_HIGHLIGHT_COLOR;
      const currentSelectedNodeColor = isDarkMode ? DARK_NODE_SELECTED_COLOR : NODE_SELECTED_COLOR;
      const currentProcessColor = isDarkMode ? DARK_PROCESS_COLOR : PROCESS_COLOR;
      const currentResourceColor = isDarkMode ? DARK_RESOURCE_COLOR : RESOURCE_COLOR;


      nodes.forEach((node) => { // Node Animation Update
        if (node.isAnimating) {
          const elapsed = now - node.animationStartTime;
          const progress = Math.min(elapsed / ANIMATION_DURATION, 1);
          const easedProgress = easeOutCubic(progress);
          node.currentScale = node.startScale + (node.targetScale - node.startScale) * easedProgress;
          node.currentAlpha = node.startAlpha + (node.targetAlpha - node.startAlpha) * easedProgress;
          if (progress < 1) {
            needsAnotherFrame = true;
          } else {
            node.isAnimating = false;
            node.currentScale = node.targetScale; // Ensure final state
            node.currentAlpha = node.targetAlpha;
            if (node.targetAlpha === 0) { // Remove node after fade out
                nodes = nodes.filter(n => n.id !== node.id);
                // Also remove edges connected to this node
                edges = edges.filter(e => e.from !== node.id && e.to !== node.id);
                updateButtonStates(); // Update buttons as node is gone
            }
          }
        } else {
            node.currentScale = 1.0;
            node.currentAlpha = 1.0;
        }
      });

      edges.forEach((edge) => { // Draw Edges
        const node1 = findNodeById(edge.from);
        const node2 = findNodeById(edge.to);
        if (!node1 || !node2) return;

        const edgeAlpha = Math.min(node1.currentAlpha ?? 1.0, node2.currentAlpha ?? 1.0);
        if (edgeAlpha <= 0) return; // Don't draw if invisible

        const { start, end } = getEdgePoints(node1, node2);
        let edgeColor = edge.type === "request" ? currentRequestEdgeColor : currentAssignEdgeColor;
        let lineWidth = NORMAL_EDGE_WIDTH;

        // Highlight selected edge
        if (selectedNode1 && selectedNode2 &&
            ((edge.from === selectedNode1.id && edge.to === selectedNode2.id) ||
             (edge.from === selectedNode2.id && edge.to === selectedNode1.id))) {
          edgeColor = currentSelectedEdgeColor;
          lineWidth = HIGHLIGHTED_EDGE_WIDTH;
        }

        // Highlight deadlocked edge
        if (deadlockedNodes.has(edge.from) && deadlockedNodes.has(edge.to)) {
            edgeColor = currentDeadlockColor;
            lineWidth = HIGHLIGHTED_EDGE_WIDTH;
        }

        ctx.save();
        ctx.globalAlpha = edgeAlpha;
        drawArrow(ctx, start.x, start.y, end.x, end.y, edgeColor, lineWidth);

        // Assignment Animation Dot
        if (edge.type === 'assignment' && edge.isAnimating) {
            hasAssignmentEdges = true;
            const elapsed = now - edge.animationStartTime;
            const progress = (elapsed % ASSIGNMENT_ANIMATION_SPEED) / ASSIGNMENT_ANIMATION_SPEED;
            const dotX = start.x + (end.x - start.x) * progress;
            const dotY = start.y + (end.y - start.y) * progress;
            ctx.fillStyle = edgeColor; // Use edge color for dot
            ctx.beginPath();
            ctx.arc(dotX, dotY, ANIMATION_DOT_SIZE, 0, Math.PI * 2);
            ctx.fill();
            needsAnotherFrame = true; // Keep animating if dots are moving
        }
        ctx.restore();
      });

      nodes.forEach((node) => { // Draw Nodes
        if (node.currentAlpha <= 0) return; // Don't draw if invisible

        ctx.save();
        ctx.globalAlpha = node.currentAlpha;
        ctx.translate(node.x, node.y);
        ctx.scale(node.currentScale, node.currentScale);
        ctx.lineWidth = 3;
        ctx.strokeStyle = currentStrokeColor;
        ctx.fillStyle = node.type === "process" ? currentProcessColor : currentResourceColor;

        // Selection and Deadlock Highlighting
        let isSelected = (selectedNode1 && node.id === selectedNode1.id) || (selectedNode2 && node.id === selectedNode2.id);
        let isDeadlocked = deadlockedNodes.has(node.id);

        if (isDeadlocked) {
            ctx.strokeStyle = currentDeadlockColor;
            ctx.lineWidth = 5;
        } else if (isSelected) {
            ctx.strokeStyle = currentSelectedNodeColor;
            ctx.lineWidth = 5;
        }

        // Draw Shape
        if (node.type === "process") {
          ctx.beginPath();
          ctx.arc(0, 0, PROCESS_RADIUS, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else {
          const halfSize = RESOURCE_SIZE / 2;
          ctx.fillRect(-halfSize, -halfSize, RESOURCE_SIZE, RESOURCE_SIZE);
          ctx.strokeRect(-halfSize, -halfSize, RESOURCE_SIZE, RESOURCE_SIZE);

          // Draw Instances Text
          ctx.fillStyle = currentInstanceTextColor;
          ctx.font = `${RESOURCE_TEXT_FONT_SIZE}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const available = getAvailableInstances(node);
          ctx.fillText(`${available}/${node.totalInstances}`, 0, 16);
        }

        // Draw Node ID
        ctx.fillStyle = currentTextColor;
        ctx.font = "bold 16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const textYOffset = node.type === "process" ? 0 : (RESOURCE_SIZE / 2) +10; // Below resource box
        ctx.fillText(node.id, 0, 0);

        ctx.restore();
      });

      if (needsAnotherFrame || draggingNode || hasAssignmentEdges) {
        animationFrameId = requestAnimationFrame(draw);
      } else {
        animationFrameId = null; // Stop loop if nothing is happening
      }
    }

    // --- Graph Manipulation ---
    function _addNode(id, type, x, y, instances = 1) {
      // Check for duplicate ID
      if (findNodeById(id)) {
        logMessage("WARN", `Node with ID '${id}' already exists.`);
        return null;
      }

      const newNode = {
        id: id.toUpperCase(), // Store IDs in uppercase for consistency
        type: type,
        x: x,
        y: y,
        totalInstances: type === "resource" ? Math.max(1, instances) : 1, // Ensure at least 1 instance
        // Animation properties
        isAnimating: true,
        animationStartTime: performance.now(),
        startScale: 0.1,
        targetScale: 1.0,
        currentScale: 0.1,
        startAlpha: 0.0,
        targetAlpha: 1.0,
        currentAlpha: 0.0,
      };
      nodes.push(newNode);
      logMessage("SUCCESS", `Added ${type} '${newNode.id}'` + (type === 'resource' ? ` with ${newNode.totalInstances} instance(s).` : '.'));
      ensureAnimationLoop();
      return newNode;
    }

    function addProcess(id = null) {
      let processId = id;
      if (!processId) {
        processCounter = 1; // Start from P1
        while (findNodeById(`P${processCounter}`)) {
          processCounter++;
        }
        processId = `P${processCounter}`;
      } else if (findNodeById(id)) {
         logMessage("WARN", `Process ID '${id}' already exists.`);
         return; // Don't add if ID explicitly provided and exists
      }

      const { x, y } = getRandomPosition();
      _addNode(processId, "process", x, y);
      updateButtonStates();
    }

    function addResource(id = null, instances = 1) {
      let resourceId = id;
      if (!resourceId) {
        resourceCounter = 1; // Start from R1
        while (findNodeById(`R${resourceCounter}`)) {
          resourceCounter++;
        }
        resourceId = `R${resourceCounter}`;
      } else if (findNodeById(id)) {
         logMessage("WARN", `Resource ID '${id}' already exists.`);
         return; // Don't add if ID explicitly provided and exists
      }

      const { x, y } = getRandomPosition();
      _addNode(resourceId, "resource", x, y, instances);
      updateButtonStates();
    }

    function submitAddProcess() {
      const id = processIdInput.value.trim();
      addProcess(id || null); // Pass null if empty to auto-generate
      closeModal("addProcessModal");
    }

    function submitAddResource() {
      const id = resourceIdInput.value.trim();
      const instances = parseInt(resourceInstancesInput.value, 10) || 1;
      addResource(id || null, instances); // Pass null if empty to auto-generate
      closeModal("addResourceModal");
    }

    function submitEditProcess() {
        const originalId = editProcessOriginalIdInput.value;
        const newId = editProcessIdInput.value.trim().toUpperCase();
        const node = findNodeById(originalId);

        if (!node) {
            logMessage("ERROR", `Cannot find process with original ID '${originalId}' to edit.`);
            closeModal("editProcessModal");
            return;
        }

        if (!newId) {
            logMessage("ERROR", "Process ID cannot be empty.");
            editProcessIdInput.focus();
            return;
        }

        // Check if the new ID conflicts with another existing node
        if (newId !== originalId && findNodeById(newId)) {
            logMessage("ERROR", `Process ID '${newId}' already exists.`);
            editProcessIdInput.focus();
            return;
        }

        // Update node ID
        node.id = newId;

        // Update edges connected to this node
        edges.forEach(edge => {
            if (edge.from === originalId) edge.from = newId;
            if (edge.to === originalId) edge.to = newId;
        });

        logMessage("SUCCESS", `Process '${originalId}' renamed to '${newId}'.`);
        closeModal("editProcessModal");
        clearSelection(); // Clear selection after edit
        ensureAnimationLoop();
    }

    function submitEditResource() {
        const originalId = editResourceOriginalIdInput.value;
        const newId = editResourceIdInput.value.trim().toUpperCase();
        const newInstances = parseInt(editResourceInstancesInput.value, 10);
        const node = findNodeById(originalId);

        if (!node) {
            logMessage("ERROR", `Cannot find resource with original ID '${originalId}' to edit.`);
            closeModal("editResourceModal");
            return;
        }

        if (!newId) {
            logMessage("ERROR", "Resource ID cannot be empty.");
            editResourceIdInput.focus();
            return;
        }

        if (isNaN(newInstances) || newInstances < 1) {
            logMessage("ERROR", "Number of instances must be a positive integer.");
            editResourceInstancesInput.focus();
            return;
        }

        // Check if the new ID conflicts with another existing node
        if (newId !== originalId && findNodeById(newId)) {
            logMessage("ERROR", `Resource ID '${newId}' already exists.`);
            editResourceIdInput.focus();
            return;
        }

        const assignedCount = getAssignedInstancesCount(originalId);
        if (newInstances < assignedCount) {
            logMessage("ERROR", `Cannot set instances (${newInstances}) less than currently assigned (${assignedCount}).`);
            editResourceInstancesInput.focus();
            return;
        }

        // Update node properties
        const oldInstances = node.totalInstances;
        node.id = newId;
        node.totalInstances = newInstances;

        // Update edges connected to this node
        edges.forEach(edge => {
            if (edge.from === originalId) edge.from = newId;
            if (edge.to === originalId) edge.to = newId;
        });

        logMessage("SUCCESS", `Resource '${originalId}' updated to ID '${newId}' and ${newInstances} instance(s) (was ${oldInstances}).`);
        closeModal("editResourceModal");
        clearSelection(); // Clear selection after edit
        ensureAnimationLoop();
    }


    function addEdge(type) {
      if (!selectedNode1 || !selectedNode2) {
        logMessage("WARN", "Select two nodes first.");
        return;
      }
      if (selectedNode1.type === selectedNode2.type) {
        logMessage("WARN", "Edges must connect a Process and a Resource.");
        return;
      }

      let processNode, resourceNode;
      if (selectedNode1.type === "process") {
        processNode = selectedNode1;
        resourceNode = selectedNode2;
      } else {
        processNode = selectedNode2;
        resourceNode = selectedNode1;
      }

      const fromNode = type === "request" ? processNode : resourceNode;
      const toNode = type === "request" ? resourceNode : processNode;

      // Check if edge already exists
      const edgeExists = edges.some(
        (e) => e.from === fromNode.id && e.to === toNode.id
      );
      if (edgeExists) {
        logMessage("INFO", `Edge from '${fromNode.id}' to '${toNode.id}' already exists.`);
        return;
      }

      // Check for assignment availability
      if (type === "assignment") {
        const available = getAvailableInstances(resourceNode);
        if (available <= 0) {
          logMessage("WARN", `No available instances of Resource '${resourceNode.id}' to assign.`);
          return;
        }
        // Check if this process already holds an instance (prevent multiple assignments of same resource type to same process)
        const alreadyAssigned = edges.some(e => e.from === resourceNode.id && e.to === processNode.id && e.type === 'assignment');
        if (alreadyAssigned) {
            logMessage("WARN", `Process '${processNode.id}' already holds an instance of Resource '${resourceNode.id}'.`);
            return;
        }
      }

      // Check if adding an assignment edge would satisfy an existing request edge
      let removedRequest = false;
      if (type === "assignment") {
          const requestIndex = edges.findIndex(e => e.from === processNode.id && e.to === resourceNode.id && e.type === 'request');
          if (requestIndex > -1) {
              edges.splice(requestIndex, 1); // Remove the request edge
              removedRequest = true;
              logMessage("INFO", `Request edge P:${processNode.id} -> R:${resourceNode.id} satisfied and removed.`);
          }
      }


      const newEdge = {
        from: fromNode.id,
        to: toNode.id,
        type: type,
        isAnimating: type === 'assignment', // Only animate assignment edges initially
        animationStartTime: type === 'assignment' ? performance.now() : 0
      };
      edges.push(newEdge);
      logMessage("SUCCESS", `Added ${type} edge: ${fromNode.type === 'process' ? 'P':'R'}:${fromNode.id} -> ${toNode.type === 'process' ? 'P':'R'}:${toNode.id}.`);

      clearSelection(); // Clear selection after adding edge
      updateButtonStates();
      ensureAnimationLoop();
    }

    function releaseResource() {
        if (!selectedNode1 || !selectedNode2) {
            logMessage("WARN", "Select a Process and its assigned Resource first.");
            return;
        }
        if (selectedNode1.type === selectedNode2.type) {
            logMessage("WARN", "Select one Process and one Resource.");
            return;
        }

        let processNode, resourceNode;
        if (selectedNode1.type === "process") {
            processNode = selectedNode1;
            resourceNode = selectedNode2;
        } else {
            processNode = selectedNode2;
            resourceNode = selectedNode1;
        }

        const edgeIndex = edges.findIndex(e => e.from === resourceNode.id && e.to === processNode.id && e.type === 'assignment');

        if (edgeIndex === -1) {
            logMessage("WARN", `No assignment edge found from Resource '${resourceNode.id}' to Process '${processNode.id}' to release.`);
            return;
        }

        edges.splice(edgeIndex, 1);
        logMessage("SUCCESS", `Resource '${resourceNode.id}' released by Process '${processNode.id}'.`);
        clearSelection();
        updateButtonStates();
        ensureAnimationLoop();
    }


    function removeSelectedEdge() {
        if (!selectedNode1 || !selectedNode2) {
            logMessage("WARN", "Select two connected nodes to remove the edge between them.");
            return;
        }

        const edgeIndex1 = edges.findIndex(e => e.from === selectedNode1.id && e.to === selectedNode2.id);
        const edgeIndex2 = edges.findIndex(e => e.from === selectedNode2.id && e.to === selectedNode1.id);

        if (edgeIndex1 !== -1) {
            const removedEdge = edges.splice(edgeIndex1, 1)[0];
            logMessage("SUCCESS", `Removed ${removedEdge.type} edge from '${removedEdge.from}' to '${removedEdge.to}'.`);
        } else if (edgeIndex2 !== -1) {
            const removedEdge = edges.splice(edgeIndex2, 1)[0];
            logMessage("SUCCESS", `Removed ${removedEdge.type} edge from '${removedEdge.from}' to '${removedEdge.to}'.`);
        } else {
            logMessage("WARN", `No edge found between '${selectedNode1.id}' and '${selectedNode2.id}'.`);
            return; // Return early if no edge was found
        }

        clearSelection();
        updateButtonStates();
        ensureAnimationLoop();
    }

    function removeSelectedNode() {
      if (!selectedNode1 || selectedNode2) {
        logMessage("WARN", "Select exactly one node to remove.");
        return;
      }

      const nodeToRemove = selectedNode1;

      // Start fade-out animation instead of immediate removal
      nodeToRemove.isAnimating = true;
      nodeToRemove.animationStartTime = performance.now();
      nodeToRemove.startScale = nodeToRemove.currentScale ?? 1.0;
      nodeToRemove.targetScale = 0.1;
      nodeToRemove.startAlpha = nodeToRemove.currentAlpha ?? 1.0;
      nodeToRemove.targetAlpha = 0.0;

      logMessage("SUCCESS", `Removing ${nodeToRemove.type} '${nodeToRemove.id}'...`);

      // Clear selection and update buttons immediately
      clearSelection(); // This also calls updateButtonStates
      ensureAnimationLoop(); // Start animation loop
    }

    function clearSelection() {
      selectedNode1 = null;
      selectedNode2 = null;
      deadlockedNodes.clear(); // Also clear deadlock highlights on selection clear
      updateButtonStates();
      ensureAnimationLoop(); // Redraw to remove highlights
    }

    function clearAll() {
      if (nodes.length === 0 && edges.length === 0) {
          logMessage("INFO", "Canvas is already empty.");
          return;
      }
      if (confirm("Are you sure you want to clear the entire canvas?")) {
        nodes = [];
        edges = [];
        processCounter = 0;
        resourceCounter = 0;
        clearSelection(); // Resets selection and updates buttons
        logMessage("SUCCESS", "Canvas cleared.");
        ensureAnimationLoop();
      }
    }

    function getRandomPosition() {
      const padding = Math.max(PROCESS_RADIUS, RESOURCE_SIZE / 2) + 10; // Padding from edges
      const x = padding + Math.random() * (canvas.clientWidth - 2 * padding);
      const y = padding + Math.random() * (canvas.clientHeight - 2 * padding);
      return { x, y };
    }

    // --- Deadlock Detection Logic ---
    function detectDeadlock(visualize = false) {
        if (isVisualizingDeadlock) {
            logMessage("WARN", "Deadlock visualization is already in progress.");
            return;
        }
        deadlockedNodes.clear(); // Clear previous results

        const adj = new Map(); // Adjacency list (nodeId -> list of neighborIds)
        const nodeMap = new Map(nodes.map(n => [n.id, n])); // For quick node lookup

        // Build adjacency list from edges
        edges.forEach(edge => {
            if (!adj.has(edge.from)) adj.set(edge.from, []);
            adj.get(edge.from).push(edge.to);
        });

        const visited = new Set(); // Nodes visited in the current DFS path
        const recursionStack = new Set(); // Nodes currently in the recursion stack
        const cyclesFound = []; // Store nodes involved in each cycle found

        function dfs(nodeId) {
            const node = nodeMap.get(nodeId);
            if (!node) return false; // Should not happen if graph is consistent

            visited.add(nodeId);
            recursionStack.add(nodeId);

            const neighbors = adj.get(nodeId) || [];
            for (const neighborId of neighbors) {
                if (!visited.has(neighborId)) {
                    if (dfs(neighborId)) {
                        // Cycle detected downstream
                        if (cyclesFound.length === 0 || !cyclesFound[cyclesFound.length - 1].includes(nodeId)) {
                             // Only add if this node is part of the *newly* found cycle path being unwound
                             if (recursionStack.has(nodeId)) { // Check if it's still on the stack (part of the cycle)
                                if (cyclesFound.length === 0 || cyclesFound[cyclesFound.length - 1][0] !== neighborId) {
                                    // Start a new cycle list if the neighbor isn't the start of the current one
                                    cyclesFound.push([]);
                                }
                                cyclesFound[cyclesFound.length - 1].unshift(nodeId); // Add to the start
                             }
                        }
                        return true; // Propagate cycle found signal up
                    }
                } else if (recursionStack.has(neighborId)) {
                    // Cycle detected: neighbor is already in the current recursion stack
                    cyclesFound.push([nodeId, neighborId]); // Start the cycle list
                    return true; // Cycle found
                }
            }

            recursionStack.delete(nodeId); // Remove node from stack as we backtrack
            return false;
        }

        // Run DFS from all nodes to find all possible cycles
        for (const node of nodes) {
            if (!visited.has(node.id)) {
                dfs(node.id);
            }
        }

        if (cyclesFound.length > 0) {
            let allCycleNodes = new Set();
            let cycleMessages = [];
            cyclesFound.forEach((cyclePath, index) => {
                // Refine cycle path: sometimes DFS adds extra nodes at the start during unwinding.
                // Find the first occurrence of the end node in the path to get the true cycle.
                const cycleStartNode = cyclePath[cyclePath.length - 1];
                const startIndex = cyclePath.indexOf(cycleStartNode);
                const actualCycle = cyclePath.slice(startIndex);

                actualCycle.forEach(id => allCycleNodes.add(id));
                cycleMessages.push(`Cycle ${index + 1}: ${actualCycle.join(" -> ")}`);
            });

            deadlockedNodes = allCycleNodes; // Update the set for highlighting
            logMessage("DEADLOCK", `Deadlock detected! Involved nodes: ${Array.from(allCycleNodes).join(", ")}.`);
            cycleMessages.forEach(msg => logMessage("VIZ_RESULT", msg)); // Log each cycle path
            ensureAnimationLoop(); // Redraw to show highlights
            return true; // Deadlock found
        } else {
            logMessage("SUCCESS", "No deadlocks detected.");
            ensureAnimationLoop(); // Redraw to clear any previous highlights
            return false; // No deadlock
        }
    }


    // --- Deadlock Visualization Logic ---
    function* deadlockVisualizationGenerator() {
      logMessage("VIZ", "Starting Deadlock Visualization...");
      yield { type: "START" }; // Signal start

      const adj = new Map();
      const nodeMap = new Map(nodes.map(n => [n.id, n]));
      edges.forEach(edge => {
        if (!adj.has(edge.from)) adj.set(edge.from, []);
        adj.get(edge.from).push(edge.to);
      });

      const visited = new Set(); // Nodes fully explored
      const recursionStack = new Set(); // Nodes in current DFS path
      const parentMap = new Map(); // Track parent for cycle path reconstruction
      let cycleFound = false;
      const allCyclesNodes = new Set(); // Collect all nodes involved in any cycle

      function* dfsVisualize(nodeId, depth = 0) {
        const node = nodeMap.get(nodeId);
        if (!node) return false;

        visited.add(nodeId);
        recursionStack.add(nodeId);
        yield { type: "STEP", message: `${"  ".repeat(depth)}Visiting node: ${nodeId}`, highlight: nodeId, stack: Array.from(recursionStack) };

        const neighbors = adj.get(nodeId) || [];
        for (const neighborId of neighbors) {
          parentMap.set(neighborId, nodeId); // Track parent for path reconstruction

          yield { type: "STEP", message: `${"  ".repeat(depth)} Checking edge: ${nodeId} -> ${neighborId}`, highlight: [nodeId, neighborId], stack: Array.from(recursionStack) };

          if (!visited.has(neighborId)) {
            // Explore unvisited neighbor
            const generator = dfsVisualize(neighborId, depth + 1);
            let result = yield* generator; // Delegate to the sub-generator

            if (result) { // Cycle found downstream
              cycleFound = true; // Mark that at least one cycle was found globally
              // Don't immediately return true here, continue checking other neighbors
              // from the current node to find *all* cycles originating from/passing through here.
            }
          } else if (recursionStack.has(neighborId)) {
            // Cycle detected! neighborId is already in the current path
            cycleFound = true;
            const cyclePath = [neighborId];
            let current = nodeId;
            while (current !== neighborId) {
              cyclePath.unshift(current);
              allCyclesNodes.add(current); // Add node to the set of all cycle nodes
              current = parentMap.get(current);
              if (!current || cyclePath.length > nodes.length) { // Safety break
                  console.error("Error reconstructing cycle path");
                  break;
              }
            }
            cyclePath.unshift(neighborId); // Add the start node again to close the loop visually
            allCyclesNodes.add(neighborId); // Add the final node

            yield { type: "CYCLE_FOUND", message: `Cycle detected: ${cyclePath.join(" -> ")}`, cycleNodes: cyclePath };
            // Don't return true immediately, continue searching for other cycles
          } else {
             yield { type: "STEP", message: `${"  ".repeat(depth)} Node ${neighborId} already visited and not in current path. Skipping.`, highlight: neighborId, stack: Array.from(recursionStack) };
          }
        }

        recursionStack.delete(nodeId); // Backtrack
        yield { type: "STEP", message: `${"  ".repeat(depth)}Finished exploring node: ${nodeId}. Backtracking.`, highlight: nodeId, stack: Array.from(recursionStack) };
        // Return true if a cycle was found *during this specific invocation or its children*
        // This signal is primarily used internally by the generator delegation (yield*)
        // The global `cycleFound` tracks if *any* cycle was found overall.
        // We return false here now, as we want the main loop to iterate through all nodes.
        return false; // Let the main loop continue
      }

      // Run DFS from all nodes
      for (const node of nodes) {
        if (!visited.has(node.id)) {
          parentMap.clear(); // Reset parent map for each new starting DFS tree
          yield* dfsVisualize(node.id);
        }
      }

      if (cycleFound) {
        yield { type: "RESULT", message: `Deadlock visualization complete. Cycles found involving nodes: ${Array.from(allCyclesNodes).join(", ")}`, finalHighlight: Array.from(allCyclesNodes) };
      } else {
        yield { type: "RESULT", message: "Deadlock visualization complete. No cycles found.", finalHighlight: [] };
      }
    }

    function startDeadlockVisualization() {
        if (isVisualizingDeadlock) return;
        isVisualizingDeadlock = true;
        deadlockedNodes.clear(); // Clear previous highlights
        deadlockVizGeneratorInstance = deadlockVisualizationGenerator();
        bodyElement.classList.add("visualizing");
        canvas.classList.add("visualizing");
        updateButtonStates(); // Disable normal controls, enable viz controls
        logMessage("VIZ", "Visualization started. Use Step/Run controls.");
        stepDeadlockVisualization(); // Execute the first step
    }

    function stepDeadlockVisualization() {
        if (!isVisualizingDeadlock || !deadlockVizGeneratorInstance) return;

        const result = deadlockVizGeneratorInstance.next();
        deadlockedNodes.clear(); // Clear previous step highlight

        if (result.done || !result.value) {
            logMessage("VIZ", "Visualization finished or generator yielded undefined.");
            stopDeadlockVisualization(false); // Stop without explicit user action if done
            return;
        }

        const stepData = result.value;
        logMessage("VIZ_STEP", stepData.message, true); // Log step message

        // Highlight based on step type
        if (stepData.type === "STEP" || stepData.type === "CYCLE_FOUND") {
            if (Array.isArray(stepData.highlight)) { // Edge highlight
                // Highlight the edge (visualized by highlighting nodes in draw())
                stepData.highlight.forEach(id => deadlockedNodes.add(id));
            } else if (stepData.highlight) { // Node highlight
                deadlockedNodes.add(stepData.highlight);
            }
            // Optionally highlight the recursion stack differently if needed
            // if (stepData.stack) { ... }
        }
         if (stepData.type === "CYCLE_FOUND" && stepData.cycleNodes) {
             stepData.cycleNodes.forEach(id => deadlockedNodes.add(id)); // Highlight cycle nodes
             logMessage("VIZ_RESULT", `Cycle Found: ${stepData.cycleNodes.join(" -> ")}`);
         }


        if (stepData.type === "RESULT") {
            logMessage(stepData.finalHighlight.length > 0 ? "DEADLOCK" : "SUCCESS", stepData.message);
            stepData.finalHighlight.forEach(id => deadlockedNodes.add(id)); // Final highlight
            stopDeadlockVisualization(false); // Auto-stop when result is reached
        }

        ensureAnimationLoop(); // Redraw with new highlights
    }

    function runDeadlockVisualizationToEnd() {
        if (!isVisualizingDeadlock || !deadlockVizGeneratorInstance) return;

        logMessage("VIZ", "Running visualization to end...");
        let result;
        let finalData = null;
        let steps = 0;
        const maxSteps = nodes.length * nodes.length * 2; // Safety break

        // Temporarily disable step-by-step logging during run-to-end for performance
        const originalRenderLogs = renderLogs;
        renderLogs = () => {}; // No-op

        do {
            result = deadlockVizGeneratorInstance.next();
            if (!result.done && result.value) {
                finalData = result.value; // Keep track of the last yielded value
                 if (finalData.type === "CYCLE_FOUND") {
                     logMessage("VIZ_RESULT", `Cycle Found: ${finalData.cycleNodes.join(" -> ")}`); // Log cycles even when running fast
                 }
            }
            steps++;
        } while (!result.done && steps < maxSteps);

        renderLogs = originalRenderLogs; // Restore logging

        if (steps >= maxSteps) {
             logMessage("ERROR", "Visualization run exceeded maximum steps. Stopping.");
        }

        // Process the final result state
        deadlockedNodes.clear();
        if (finalData && finalData.type === "RESULT") {
            logMessage(finalData.finalHighlight.length > 0 ? "DEADLOCK" : "SUCCESS", finalData.message);
            finalData.finalHighlight.forEach(id => deadlockedNodes.add(id));
        } else if (cycleFound) { // Fallback if generator finished unexpectedly after finding a cycle
             logMessage("DEADLOCK", "Visualization finished. Cycles were detected.");
             // Highlight all nodes found in cycles during the run (might require collecting them)
             // For simplicity, we might just rely on the last 'finalHighlight' if available
        } else {
             logMessage("SUCCESS", "Visualization finished. No cycles detected.");
        }

        stopDeadlockVisualization(false); // Stop viz state
        renderLogs(); // Render all collected logs at once
        ensureAnimationLoop(); // Final redraw
    }


    function stopDeadlockVisualization(log = true) {
        if (!isVisualizingDeadlock) return;
        isVisualizingDeadlock = false;
        deadlockVizGeneratorInstance = null;
        bodyElement.classList.remove("visualizing");
        canvas.classList.remove("visualizing");
        // Don't clear deadlockedNodes here if we want the final result to persist
        updateButtonStates();
        if (log) logMessage("VIZ", "Visualization stopped by user.");
        ensureAnimationLoop(); // Redraw to ensure correct state
    }


    // --- UI Updates ---
    function updateButtonStates() {
      const oneSelected = selectedNode1 && !selectedNode2;
      const twoSelected = selectedNode1 && selectedNode2;
      const processSelected = (selectedNode1?.type === 'process') || (selectedNode2?.type === 'process');
      const resourceSelected = (selectedNode1?.type === 'resource') || (selectedNode2?.type === 'resource');
      const pAndRSelected = processSelected && resourceSelected && twoSelected;

      // Normal Controls
      requestEdgeBtn.disabled = !pAndRSelected || isVisualizingDeadlock;
      assignEdgeBtn.disabled = !pAndRSelected || isVisualizingDeadlock;
      releaseResourceBtn.disabled = !pAndRSelected || isVisualizingDeadlock;
      removeEdgeBtn.disabled = !twoSelected || isVisualizingDeadlock;
      removeNodeBtn.disabled = !oneSelected || isVisualizingDeadlock;
      editNodeBtn.disabled = !oneSelected || isVisualizingDeadlock; // Enable edit for one selected node
      visualizeDeadlockBtn.disabled = isVisualizingDeadlock || nodes.length === 0;
      directDeadlockBtn.disabled = isVisualizingDeadlock || nodes.length === 0;
      clearSelectionBtn.disabled = !selectedNode1 || isVisualizingDeadlock; // Disable if nothing selected
      scriptButton.disabled = isVisualizingDeadlock;
      exportScriptButton.disabled = isVisualizingDeadlock || nodes.length === 0;
      clearAllButton.disabled = isVisualizingDeadlock;
      aboutButton.disabled = isVisualizingDeadlock;
      darkModeToggle.disabled = isVisualizingDeadlock;

      // Disable add buttons during visualization too
      addProcessBtn.disabled = isVisualizingDeadlock;
      addResourceBtn.disabled = isVisualizingDeadlock;


      // Visualization Controls (only relevant if isVisualizingDeadlock is true)
      stepDeadlockVizBtn.disabled = !isVisualizingDeadlock;
      runDeadlockVizBtn.disabled = !isVisualizingDeadlock;
      stopDeadlockVizBtn.disabled = !isVisualizingDeadlock;

      // Update button text/icons based on selection for context
       if (pAndRSelected) {
            let pNode = selectedNode1.type === 'process' ? selectedNode1 : selectedNode2;
            let rNode = selectedNode1.type === 'resource' ? selectedNode1 : selectedNode2;
            requestEdgeBtn.title = `Request ${rNode.id} for ${pNode.id} (Q)`;
            assignEdgeBtn.title = `Assign ${rNode.id} to ${pNode.id} (A)`;
            releaseResourceBtn.title = `Release ${rNode.id} from ${pNode.id} (L)`;
       } else {
            requestEdgeBtn.title = "Shortcut: Q";
            assignEdgeBtn.title = "Shortcut: A";
            releaseResourceBtn.title = "Shortcut: L";
       }
       if (oneSelected) {
           removeNodeBtn.title = `Remove ${selectedNode1.id} (Delete/Bksp/X)`;
           editNodeBtn.title = `Edit ${selectedNode1.id} (M)`;
       } else {
           removeNodeBtn.title = "Shortcut: Delete/Backspace/X";
           editNodeBtn.title = "Shortcut: M";
       }
       if (twoSelected) {
           removeEdgeBtn.title = `Remove edge between ${selectedNode1.id} and ${selectedNode2.id}`;
       } else {
           removeEdgeBtn.title = "Remove Edge";
       }
    }

    // --- Event Listeners ---
    function setupEventListeners() {
      // Buttons
      addProcessBtn.addEventListener("click", () => openModal("addProcessModal"));
      addResourceBtn.addEventListener("click", () => openModal("addResourceModal"));
      requestEdgeBtn.addEventListener("click", () => addEdge("request"));
      assignEdgeBtn.addEventListener("click", () => addEdge("assignment"));
      releaseResourceBtn.addEventListener("click", releaseResource);
      removeEdgeBtn.addEventListener("click", removeSelectedEdge);
      removeNodeBtn.addEventListener("click", removeSelectedNode);
      editNodeBtn.addEventListener("click", () => { // Open correct edit modal
          if (selectedNode1?.type === 'process') openModal('editProcessModal');
          else if (selectedNode1?.type === 'resource') openModal('editResourceModal');
      });
      visualizeDeadlockBtn.addEventListener("click", startDeadlockVisualization);
      directDeadlockBtn.addEventListener("click", () => detectDeadlock(false)); // Direct detection
      clearSelectionBtn.addEventListener("click", clearSelection);
      scriptButton.addEventListener("click", () => openModal("scriptModal"));
      exportScriptButton.addEventListener("click", () => openModal("exportModal"));
      aiGenerateBtn.addEventListener("click", () => openModal('aiGenerateModal'));
      clearAllButton.addEventListener("click", clearAll);
      aboutButton.addEventListener("click", () => openModal("aboutModal"));
      darkModeToggle.addEventListener("click", toggleDarkMode); // Dark Mode Toggle

      // Visualization Buttons
      stepDeadlockVizBtn.addEventListener("click", stepDeadlockVisualization);
      runDeadlockVizBtn.addEventListener("click", runDeadlockVisualizationToEnd);
      stopDeadlockVizBtn.addEventListener("click", () => stopDeadlockVisualization(true)); // Stop via button logs message

      // Copy Script Button
      copyScriptButton.addEventListener("click", copyScriptToClipboard);


      // Canvas Interaction
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("dblclick", handleDoubleClick); // Handle double click for editing

      // Keyboard Shortcuts
      window.addEventListener("keydown", handleKeyDown);

      // Modal Enter Key Submission
      processIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitAddProcess(); });
      resourceIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitAddResource(); });
      resourceInstancesInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitAddResource(); });
      editProcessIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitEditProcess(); });
      editResourceIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitEditResource(); });
      editResourceInstancesInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitEditResource(); });
      // Don't submit script modal on Enter in textarea, allow newlines
      aiInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && !event.shiftKey) { // Allow Shift+Enter for newlines
              event.preventDefault(); // Prevent default newline in textarea
              submitAiGenerate();
          }
      });
    }

    function handleMouseDown(e) {
      if (isVisualizingDeadlock) return; // Ignore clicks during visualization
      const pos = getMousePos(canvas, e);
      const clickedNode = getNodeAtPos(pos.x, pos.y);

      if (clickedNode) {
        draggingNode = clickedNode;
        dragOffsetX = pos.x - clickedNode.x;
        dragOffsetY = pos.y - clickedNode.y;
        // Don't select immediately on mousedown, wait for mouseup without drag
      } else {
        // Clicked on empty space - potentially start clearing selection on mouseup
        draggingNode = null;
      }
      ensureAnimationLoop(); // Start animation loop for potential drag
    }

    function handleMouseMove(e) {
      if (draggingNode && !isVisualizingDeadlock) {
        const pos = getMousePos(canvas, e);
        draggingNode.x = pos.x - dragOffsetX;
        draggingNode.y = pos.y - dragOffsetY;
        // Keep node within canvas bounds (optional)
        const padding = (draggingNode.type === 'process' ? PROCESS_RADIUS : RESOURCE_SIZE / 2) * (draggingNode.currentScale ?? 1.0);
        draggingNode.x = Math.max(padding, Math.min(canvas.clientWidth - padding, draggingNode.x));
        draggingNode.y = Math.max(padding, Math.min(canvas.clientHeight - padding, draggingNode.y));
        ensureAnimationLoop(); // Ensure redraw during drag
      }
    }

    function handleMouseUp(e) {
        if (isVisualizingDeadlock) return;
        const pos = getMousePos(canvas, e);
        const clickedNode = getNodeAtPos(pos.x, pos.y); // Check node at mouseup position

        if (draggingNode) {
            // If we were dragging a node, check if it moved significantly
            const dx = pos.x - (draggingNode.x + dragOffsetX);
            const dy = pos.y - (draggingNode.y + dragOffsetY);
            const movedDistance = Math.sqrt(dx*dx + dy*dy);

            if (movedDistance < 5) { // Threshold to differentiate click from drag
                // It was a click on the node we started dragging
                handleNodeSelection(draggingNode);
            } else {
                 logMessage("INFO", `Moved ${draggingNode.type} '${draggingNode.id}'.`);
            }
        } else if (clickedNode) {
             // Clicked on a node without starting a drag on it (unlikely but possible)
             handleNodeSelection(clickedNode);
        } else {
            // Clicked on empty space, clear selection
            clearSelection();
        }

        draggingNode = null; // End drag operation
        updateButtonStates();
        ensureAnimationLoop(); // Redraw needed for selection changes or final drag position
    }

    function handleDoubleClick(e) {
        if (isVisualizingDeadlock) return;
        const pos = getMousePos(canvas, e);
        const clickedNode = getNodeAtPos(pos.x, pos.y);

        if (clickedNode) {
            // Select the node first
            selectedNode1 = clickedNode;
            selectedNode2 = null;
            updateButtonStates(); // Update buttons to enable edit

            // Open the appropriate edit modal
            if (clickedNode.type === 'process') {
                openModal('editProcessModal');
            } else if (clickedNode.type === 'resource') {
                openModal('editResourceModal');
            }
            ensureAnimationLoop(); // Redraw selection highlight
        }
    }

    function handleNodeSelection(node) {
        if (!node) return;

        if (!selectedNode1) {
            selectedNode1 = node;
        } else if (!selectedNode2) {
            if (node.id !== selectedNode1.id) {
                selectedNode2 = node;
            } else {
                // Clicked the same node again, deselect it
                selectedNode1 = null;
            }
        } else {
            // Both are selected, start fresh with the new click
            selectedNode1 = node;
            selectedNode2 = null;
        }
        deadlockedNodes.clear(); // Clear deadlock highlights when selection changes
        updateButtonStates();
        ensureAnimationLoop();
    }


    function handleKeyDown(e) {
      // Ignore keydowns if a modal is open and the target is an input/textarea
      if (activeModal && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        // Allow Escape key even in modals to close them
        if (e.key === "Escape") {
             closeModal(activeModal);
        }
        return;
      }
       // Allow Escape key during visualization to stop it
       if (isVisualizingDeadlock && e.key === "Escape") {
           stopDeadlockVisualization(true);
           return; // Don't process other keys during viz
       }
       // Allow Space/R during visualization for controls
       if (isVisualizingDeadlock) {
           if (e.key === " ") { // Spacebar
               e.preventDefault(); // Prevent page scroll
               stepDeadlockVisualization();
           } else if (e.key.toUpperCase() === "R") {
               runDeadlockVisualizationToEnd();
           }
           return; // Don't process other keys during viz
       }

      // Normal mode shortcuts
      switch (e.key.toUpperCase()) {
        case "P": addProcessBtn.click(); break;
        case "R": addResourceBtn.click(); break;
        case "Q": if (!requestEdgeBtn.disabled) requestEdgeBtn.click(); break;
        case "A": if (!assignEdgeBtn.disabled) assignEdgeBtn.click(); break;
        case "L": if (!releaseResourceBtn.disabled) releaseResourceBtn.click(); break;
        case "DELETE":
        case "BACKSPACE":
        case "X":
          if (!removeNodeBtn.disabled) removeNodeBtn.click();
          break;
        case "M": // Edit shortcut
           if (!editNodeBtn.disabled) editNodeBtn.click();
           break;
        case "D": if (!visualizeDeadlockBtn.disabled) visualizeDeadlockBtn.click(); break;
        case "K": if (!directDeadlockBtn.disabled) directDeadlockBtn.click(); break; // Direct Detect shortcut
        case "G": // Shortcut for AI Generate
            e.preventDefault(); // Prevent default browser behavior if any
            if (!aiGenerateBtn.disabled) aiGenerateBtn.click(); // Use button click to handle disabled state
            break;
        case "ESCAPE":
            if (selectedNode1) { // Only clear selection if something is selected
                clearSelectionBtn.click();
            } else if (activeModal) { // Close modal if open and no selection
                closeModal(activeModal);
            }
          break;
        case "C": if (!clearAllButton.disabled) clearAllButton.click(); break;
        case "E": if (!exportScriptButton.disabled) exportScriptButton.click(); break; // Export shortcut
        case "T": if (!darkModeToggle.disabled) darkModeToggle.click(); break; // Dark Mode Toggle Shortcut
      }
    }

    // --- Scripting ---
    function runScript(scriptText = scriptInput.value) {
        const commands = scriptText.split(/;|\n/).map(cmd => cmd.trim()).filter(cmd => cmd && !cmd.startsWith("//"));

        logMessage("INFO", `Running script with ${commands.length} commands...`);
        let errors = 0;

        commands.forEach((cmd, index) => {
            const parts = cmd.match(/(?:[^\s"]+|"[^"]*")+/g) || []; // Split by space, respecting quotes
            if (parts.length === 0) return;

            const command = parts[0].toUpperCase();
            const args = parts.slice(1).map(arg => arg.replace(/^"|"$/g, '')); // Remove quotes

            try {
                switch (command) {
                    case "ADD":
                        if (args.length < 2) throw new Error("ADD requires type (P/R) and ID.");
                        const type = args[0].toUpperCase();
                        const id = args[1];
                        if (type === "P") {
                            if (args.length !== 2) throw new Error("ADD P requires ID.");
                            addProcess(id);
                        } else if (type === "R") {
                            if (args.length < 2 || args.length > 3) throw new Error("ADD R requires ID and optional instances.");
                            const instances = args.length === 3 ? parseInt(args[2], 10) : 1;
                            if (isNaN(instances) || instances < 1) throw new Error("Resource instances must be a positive number.");
                            addResource(id, instances);
                        } else {
                            throw new Error(`Invalid type for ADD: ${args[0]}. Use P or R.`);
                        }
                        break;
                    case "REQ":
                    case "REQUEST":
                        if (args.length !== 2) throw new Error("REQ requires ProcessID and ResourceID.");
                        selectNodesByIds(args[0], args[1]);
                        addEdge("request");
                        break;
                    case "ASSIGN":
                        if (args.length !== 2) throw new Error("ASSIGN requires ProcessID and ResourceID.");
                        selectNodesByIds(args[0], args[1]); // Note: Assignment goes R -> P
                        addEdge("assignment");
                        break;
                    case "RELEASE":
                         if (args.length !== 2) throw new Error("RELEASE requires ProcessID and ResourceID.");
                         selectNodesByIds(args[0], args[1]);
                         releaseResource();
                         break;
                    case "REMOVE":
                         if (args.length !== 1 && args.length !== 2) throw new Error("REMOVE requires NodeID or two NodeIDs for an edge.");
                         if (args.length === 1) { // Remove Node
                             selectNodesByIds(args[0], null);
                             removeSelectedNode();
                         } else { // Remove Edge
                             selectNodesByIds(args[0], args[1]);
                             removeSelectedEdge();
                         }
                         break;
                    case "CLEAR":
                        clearAll(); // Consider if confirmation is needed here? For now, script clears directly.
                        break;
                    default:
                        throw new Error(`Unknown command: ${command}`);
                }
            } catch (error) {
                logMessage("ERROR", `Script error on line ${index + 1} ('${cmd}'): ${error.message}`);
                errors++;
            } finally {
                 clearSelection(); // Clear selection after each command attempt
            }
        });

        if (errors > 0) {
            logMessage("WARN", `Script finished with ${errors} error(s).`);
        } else {
            logMessage("SUCCESS", "Script finished successfully.");
        }
        closeModal("scriptModal");
        ensureAnimationLoop(); // Ensure canvas updates after script run
    }

    // Helper for script execution
    function selectNodesByIds(id1, id2) {
        clearSelection();
        selectedNode1 = findNodeById(id1);
        if (!selectedNode1) throw new Error(`Node with ID '${id1}' not found.`);
        if (id2) {
            selectedNode2 = findNodeById(id2);
            if (!selectedNode2) throw new Error(`Node with ID '${id2}' not found.`);
        }
        updateButtonStates(); // Update based on new selection
    }

    function generateScript() {
        let script = "// Generated by RAG Simulator v2.3\n";
        script += "// Date: " + new Date().toISOString() + "\n\n";
        script += "// Processes\n";
        nodes.filter(n => n.type === 'process').forEach(p => {
            script += `ADD P "${p.id}";\n`; // Quote IDs in case they contain spaces
        });
        script += "\n// Resources\n";
        nodes.filter(n => n.type === 'resource').forEach(r => {
            script += `ADD R "${r.id}" ${r.totalInstances};\n`;
        });
        script += "\n// Edges\n";
        edges.forEach(e => {
            const fromNode = findNodeById(e.from);
            const toNode = findNodeById(e.to);
            if (!fromNode || !toNode) return; // Skip if nodes don't exist (shouldn't happen)

            if (e.type === 'request') { // P -> R
                script += `REQ "${e.from}" "${e.to}";\n`;
            } else if (e.type === 'assignment') { // R -> P
                script += `ASSIGN "${e.to}" "${e.from}"; // Note: ASSIGN takes P then R\n`;
            }
        });

        return script;
    }

    function copyScriptToClipboard() {
        const scriptText = exportScriptArea.value;
        navigator.clipboard.writeText(scriptText).then(() => {
            logMessage("SUCCESS", "Script copied to clipboard!");
            copyScriptButton.textContent = "Copied!";
            copyScriptButton.disabled = true;
            setTimeout(() => {
                 copyScriptButton.textContent = "Copy to Clipboard";
                 copyScriptButton.disabled = false;
            }, 1500);
        }).catch(err => {
            logMessage("ERROR", "Failed to copy script: " + err);
            alert("Failed to copy script. Please copy manually.");
        });
    }

    // --- AI Generation ---
    async function submitAiGenerate() {
        const userText = aiInput.value.trim();
        if (!userText) {
            logMessage("WARN", "AI Generate: Input text cannot be empty.");
            aiErrorLog.textContent = "Please enter a description.";
            aiErrorLog.style.display = 'block';
            aiInput.focus();
            return;
        }

        logMessage("INFO", `Sending description to AI: "${userText}"`);
        submitAiGenerateBtn.disabled = true;
        submitAiGenerateBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Generating...';
        aiErrorLog.style.display = 'none'; // Hide previous errors

        try {
            // Make sure your Flask app is running, likely on http://127.0.0.1:5000
            const response = await fetch('/generate-graph-from-text', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: userText }),
            });

            if (!response.ok) {
                let errorMsg = `AI generation failed: ${response.status} ${response.statusText}`;
                try {
                    const errorData = await response.json();
                    errorMsg = `AI generation failed: ${errorData.error || response.statusText}`;
                } catch (e) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const data = await response.json();
            const generatedScript = data.script;

            if (generatedScript) {
                logMessage("SUCCESS", `AI generated script:
${generatedScript}`);
                // Optionally clear existing graph before running AI script?
                // clearAllConfirm(); // Or just run on top
                runScript(generatedScript); // Pass script directly to runScript
                closeModal('aiGenerateModal'); // Close modal on success
            } else {
                throw new Error("AI returned an empty script.");
            }

        } catch (error) {
            console.error("AI Generation Error:", error);
            logMessage("ERROR", `AI Generation failed: ${error.message}`);
            aiErrorLog.textContent = `Error: ${error.message}`;
            aiErrorLog.style.display = 'block';
            submitAiGenerateBtn.disabled = false; // Re-enable button on error
            submitAiGenerateBtn.innerHTML = '<i class="fa-solid fa-robot"></i> Generate';
        }
    }


    // --- Deadlock Detection Logic ---
    function detectDeadlock(visualize = false) {
        if (isVisualizingDeadlock) {
            logMessage("WARN", "Deadlock visualization is already in progress.");
            return;
        }
        deadlockedNodes.clear(); // Clear previous results

        const adj = new Map(); // Adjacency list (nodeId -> list of neighborIds)
        const nodeMap = new Map(nodes.map(n => [n.id, n])); // For quick node lookup

        // Build adjacency list from edges
        edges.forEach(edge => {
            if (!adj.has(edge.from)) adj.set(edge.from, []);
            adj.get(edge.from).push(edge.to);
        });

        const visited = new Set(); // Nodes visited in the current DFS path
        const recursionStack = new Set(); // Nodes currently in the recursion stack
        const cyclesFound = []; // Store nodes involved in each cycle found

        function dfs(nodeId) {
            const node = nodeMap.get(nodeId);
            if (!node) return false; // Should not happen if graph is consistent

            visited.add(nodeId);
            recursionStack.add(nodeId);

            const neighbors = adj.get(nodeId) || [];
            for (const neighborId of neighbors) {
                if (!visited.has(neighborId)) {
                    if (dfs(neighborId)) {
                        // Cycle detected downstream
                        if (cyclesFound.length === 0 || !cyclesFound[cyclesFound.length - 1].includes(nodeId)) {
                             // Only add if this node is part of the *newly* found cycle path being unwound
                             if (recursionStack.has(nodeId)) { // Check if it's still on the stack (part of the cycle)
                                if (cyclesFound.length === 0 || cyclesFound[cyclesFound.length - 1][0] !== neighborId) {
                                    // Start a new cycle list if the neighbor isn't the start of the current one
                                    cyclesFound.push([]);
                                }
                                cyclesFound[cyclesFound.length - 1].unshift(nodeId); // Add to the start
                             }
                        }
                        return true; // Propagate cycle found signal up
                    }
                } else if (recursionStack.has(neighborId)) {
                    // Cycle detected: neighbor is already in the current recursion stack
                    cyclesFound.push([nodeId, neighborId]); // Start the cycle list
                    return true; // Cycle found
                }
            }

            recursionStack.delete(nodeId); // Remove node from stack as we backtrack
            return false;
        }

        // Run DFS from all nodes to find all possible cycles
        for (const node of nodes) {
            if (!visited.has(node.id)) {
                dfs(node.id);
            }
        }

        if (cyclesFound.length > 0) {
            let allCycleNodes = new Set();
            let cycleMessages = [];
            cyclesFound.forEach((cyclePath, index) => {
                // Refine cycle path: sometimes DFS adds extra nodes at the start during unwinding.
                // Find the first occurrence of the end node in the path to get the true cycle.
                const cycleStartNode = cyclePath[cyclePath.length - 1];
                const startIndex = cyclePath.indexOf(cycleStartNode);
                const actualCycle = cyclePath.slice(startIndex);

                actualCycle.forEach(id => allCycleNodes.add(id));
                cycleMessages.push(`Cycle ${index + 1}: ${actualCycle.join(" -> ")}`);
            });

            deadlockedNodes = allCycleNodes; // Update the set for highlighting
            logMessage("DEADLOCK", `Deadlock detected! Involved nodes: ${Array.from(allCycleNodes).join(", ")}.`);
            cycleMessages.forEach(msg => logMessage("VIZ_RESULT", msg)); // Log each cycle path
            ensureAnimationLoop(); // Redraw to show highlights
            return true; // Deadlock found
        } else {
            logMessage("SUCCESS", "No deadlocks detected.");
            ensureAnimationLoop(); // Redraw to clear any previous highlights
            return false; // No deadlock
        }
    }


    // --- Deadlock Visualization Logic ---
    function* deadlockVisualizationGenerator() {
      logMessage("VIZ", "Starting Deadlock Visualization...");
      yield { type: "START" }; // Signal start

      const adj = new Map();
      const nodeMap = new Map(nodes.map(n => [n.id, n]));
      edges.forEach(edge => {
        if (!adj.has(edge.from)) adj.set(edge.from, []);
        adj.get(edge.from).push(edge.to);
      });

      const visited = new Set(); // Nodes fully explored
      const recursionStack = new Set(); // Nodes in current DFS path
      const parentMap = new Map(); // Track parent for cycle path reconstruction
      let cycleFound = false;
      const allCyclesNodes = new Set(); // Collect all nodes involved in any cycle

      function* dfsVisualize(nodeId, depth = 0) {
        const node = nodeMap.get(nodeId);
        if (!node) return false;

        visited.add(nodeId);
        recursionStack.add(nodeId);
        yield { type: "STEP", message: `${"  ".repeat(depth)}Visiting node: ${nodeId}`, highlight: nodeId, stack: Array.from(recursionStack) };

        const neighbors = adj.get(nodeId) || [];
        for (const neighborId of neighbors) {
          parentMap.set(neighborId, nodeId); // Track parent for path reconstruction

          yield { type: "STEP", message: `${"  ".repeat(depth)} Checking edge: ${nodeId} -> ${neighborId}`, highlight: [nodeId, neighborId], stack: Array.from(recursionStack) };

          if (!visited.has(neighborId)) {
            // Explore unvisited neighbor
            const generator = dfsVisualize(neighborId, depth + 1);
            let result = yield* generator; // Delegate to the sub-generator

            if (result) { // Cycle found downstream
              cycleFound = true; // Mark that at least one cycle was found globally
              // Don't immediately return true here, continue checking other neighbors
              // from the current node to find *all* cycles originating from/passing through here.
            }
          } else if (recursionStack.has(neighborId)) {
            // Cycle detected! neighborId is already in the current path
            cycleFound = true;
            const cyclePath = [neighborId];
            let current = nodeId;
            while (current !== neighborId) {
              cyclePath.unshift(current);
              allCyclesNodes.add(current); // Add node to the set of all cycle nodes
              current = parentMap.get(current);
              if (!current || cyclePath.length > nodes.length) { // Safety break
                  console.error("Error reconstructing cycle path");
                  break;
              }
            }
            cyclePath.unshift(neighborId); // Add the start node again to close the loop visually
            allCyclesNodes.add(neighborId); // Add the final node

            yield { type: "CYCLE_FOUND", message: `Cycle detected: ${cyclePath.join(" -> ")}`, cycleNodes: cyclePath };
            // Don't return true immediately, continue searching for other cycles
          } else {
             yield { type: "STEP", message: `${"  ".repeat(depth)} Node ${neighborId} already visited and not in current path. Skipping.`, highlight: neighborId, stack: Array.from(recursionStack) };
          }
        }

        recursionStack.delete(nodeId); // Backtrack
        yield { type: "STEP", message: `${"  ".repeat(depth)}Finished exploring node: ${nodeId}. Backtracking.`, highlight: nodeId, stack: Array.from(recursionStack) };
        // Return true if a cycle was found *during this specific invocation or its children*
        // This signal is primarily used internally by the generator delegation (yield*)
        // The global `cycleFound` tracks if *any* cycle was found overall.
        // We return false here now, as we want the main loop to iterate through all nodes.
        return false; // Let the main loop continue
      }

      // Run DFS from all nodes
      for (const node of nodes) {
        if (!visited.has(node.id)) {
          parentMap.clear(); // Reset parent map for each new starting DFS tree
          yield* dfsVisualize(node.id);
        }
      }

      if (cycleFound) {
        yield { type: "RESULT", message: `Deadlock visualization complete. Cycles found involving nodes: ${Array.from(allCyclesNodes).join(", ")}`, finalHighlight: Array.from(allCyclesNodes) };
      } else {
        yield { type: "RESULT", message: "Deadlock visualization complete. No cycles found.", finalHighlight: [] };
      }
    }

    function startDeadlockVisualization() {
        if (isVisualizingDeadlock) return;
        isVisualizingDeadlock = true;
        deadlockedNodes.clear(); // Clear previous highlights
        deadlockVizGeneratorInstance = deadlockVisualizationGenerator();
        bodyElement.classList.add("visualizing");
        canvas.classList.add("visualizing");
        updateButtonStates(); // Disable normal controls, enable viz controls
        logMessage("VIZ", "Visualization started. Use Step/Run controls.");
        stepDeadlockVisualization(); // Execute the first step
    }

    function stepDeadlockVisualization() {
        if (!isVisualizingDeadlock || !deadlockVizGeneratorInstance) return;

        const result = deadlockVizGeneratorInstance.next();
        deadlockedNodes.clear(); // Clear previous step highlight

        if (result.done || !result.value) {
            logMessage("VIZ", "Visualization finished or generator yielded undefined.");
            stopDeadlockVisualization(false); // Stop without explicit user action if done
            return;
        }

        const stepData = result.value;
        logMessage("VIZ_STEP", stepData.message, true); // Log step message

        // Highlight based on step type
        if (stepData.type === "STEP" || stepData.type === "CYCLE_FOUND") {
            if (Array.isArray(stepData.highlight)) { // Edge highlight
                // Highlight the edge (visualized by highlighting nodes in draw())
                stepData.highlight.forEach(id => deadlockedNodes.add(id));
            } else if (stepData.highlight) { // Node highlight
                deadlockedNodes.add(stepData.highlight);
            }
            // Optionally highlight the recursion stack differently if needed
            // if (stepData.stack) { ... }
        }
         if (stepData.type === "CYCLE_FOUND" && stepData.cycleNodes) {
             stepData.cycleNodes.forEach(id => deadlockedNodes.add(id)); // Highlight cycle nodes
             logMessage("VIZ_RESULT", `Cycle Found: ${stepData.cycleNodes.join(" -> ")}`);
         }


        if (stepData.type === "RESULT") {
            logMessage(stepData.finalHighlight.length > 0 ? "DEADLOCK" : "SUCCESS", stepData.message);
            stepData.finalHighlight.forEach(id => deadlockedNodes.add(id)); // Final highlight
            stopDeadlockVisualization(false); // Auto-stop when result is reached
        }

        ensureAnimationLoop(); // Redraw with new highlights
    }

    function runDeadlockVisualizationToEnd() {
        if (!isVisualizingDeadlock || !deadlockVizGeneratorInstance) return;

        logMessage("VIZ", "Running visualization to end...");
        let result;
        let finalData = null;
        let steps = 0;
        const maxSteps = nodes.length * nodes.length * 2; // Safety break

        // Temporarily disable step-by-step logging during run-to-end for performance
        const originalRenderLogs = renderLogs;
        renderLogs = () => {}; // No-op

        do {
            result = deadlockVizGeneratorInstance.next();
            if (!result.done && result.value) {
                finalData = result.value; // Keep track of the last yielded value
                 if (finalData.type === "CYCLE_FOUND") {
                     logMessage("VIZ_RESULT", `Cycle Found: ${finalData.cycleNodes.join(" -> ")}`); // Log cycles even when running fast
                 }
            }
            steps++;
        } while (!result.done && steps < maxSteps);

        renderLogs = originalRenderLogs; // Restore logging

        if (steps >= maxSteps) {
             logMessage("ERROR", "Visualization run exceeded maximum steps. Stopping.");
        }

        // Process the final result state
        deadlockedNodes.clear();
        if (finalData && finalData.type === "RESULT") {
            logMessage(finalData.finalHighlight.length > 0 ? "DEADLOCK" : "SUCCESS", finalData.message);
            finalData.finalHighlight.forEach(id => deadlockedNodes.add(id));
        } else if (cycleFound) { // Fallback if generator finished unexpectedly after finding a cycle
             logMessage("DEADLOCK", "Visualization finished. Cycles were detected.");
             // Highlight all nodes found in cycles during the run (might require collecting them)
             // For simplicity, we might just rely on the last 'finalHighlight' if available
        } else {
             logMessage("SUCCESS", "Visualization finished. No cycles detected.");
        }

        stopDeadlockVisualization(false); // Stop viz state
        renderLogs(); // Render all collected logs at once
        ensureAnimationLoop(); // Final redraw
    }


    function stopDeadlockVisualization(log = true) {
        if (!isVisualizingDeadlock) return;
        isVisualizingDeadlock = false;
        deadlockVizGeneratorInstance = null;
        bodyElement.classList.remove("visualizing");
        canvas.classList.remove("visualizing");
        // Don't clear deadlockedNodes here if we want the final result to persist
        updateButtonStates();
        if (log) logMessage("VIZ", "Visualization stopped by user.");
        ensureAnimationLoop(); // Redraw to ensure correct state
    }


    // --- UI Updates ---
    function updateButtonStates() {
      const oneSelected = selectedNode1 && !selectedNode2;
      const twoSelected = selectedNode1 && selectedNode2;
      const processSelected = (selectedNode1?.type === 'process') || (selectedNode2?.type === 'process');
      const resourceSelected = (selectedNode1?.type === 'resource') || (selectedNode2?.type === 'resource');
      const pAndRSelected = processSelected && resourceSelected && twoSelected;

      // Normal Controls
      requestEdgeBtn.disabled = !pAndRSelected || isVisualizingDeadlock;
      assignEdgeBtn.disabled = !pAndRSelected || isVisualizingDeadlock;
      releaseResourceBtn.disabled = !pAndRSelected || isVisualizingDeadlock;
      removeEdgeBtn.disabled = !twoSelected || isVisualizingDeadlock;
      removeNodeBtn.disabled = !oneSelected || isVisualizingDeadlock;
      editNodeBtn.disabled = !oneSelected || isVisualizingDeadlock; // Enable edit for one selected node
      visualizeDeadlockBtn.disabled = isVisualizingDeadlock || nodes.length === 0;
      directDeadlockBtn.disabled = isVisualizingDeadlock || nodes.length === 0;
      clearSelectionBtn.disabled = !selectedNode1 || isVisualizingDeadlock; // Disable if nothing selected
      scriptButton.disabled = isVisualizingDeadlock;
      exportScriptButton.disabled = isVisualizingDeadlock || nodes.length === 0;
      clearAllButton.disabled = isVisualizingDeadlock;
      aboutButton.disabled = isVisualizingDeadlock;
      darkModeToggle.disabled = isVisualizingDeadlock;

      // Disable add buttons during visualization too
      addProcessBtn.disabled = isVisualizingDeadlock;
      addResourceBtn.disabled = isVisualizingDeadlock;


      // Visualization Controls (only relevant if isVisualizingDeadlock is true)
      stepDeadlockVizBtn.disabled = !isVisualizingDeadlock;
      runDeadlockVizBtn.disabled = !isVisualizingDeadlock;
      stopDeadlockVizBtn.disabled = !isVisualizingDeadlock;

      // Update button text/icons based on selection for context
       if (pAndRSelected) {
            let pNode = selectedNode1.type === 'process' ? selectedNode1 : selectedNode2;
            let rNode = selectedNode1.type === 'resource' ? selectedNode1 : selectedNode2;
            requestEdgeBtn.title = `Request ${rNode.id} for ${pNode.id} (Q)`;
            assignEdgeBtn.title = `Assign ${rNode.id} to ${pNode.id} (A)`;
            releaseResourceBtn.title = `Release ${rNode.id} from ${pNode.id} (L)`;
       } else {
            requestEdgeBtn.title = "Shortcut: Q";
            assignEdgeBtn.title = "Shortcut: A";
            releaseResourceBtn.title = "Shortcut: L";
       }
       if (oneSelected) {
           removeNodeBtn.title = `Remove ${selectedNode1.id} (Delete/Bksp/X)`;
           editNodeBtn.title = `Edit ${selectedNode1.id} (M)`;
       } else {
           removeNodeBtn.title = "Shortcut: Delete/Backspace/X";
           editNodeBtn.title = "Shortcut: M";
       }
       if (twoSelected) {
           removeEdgeBtn.title = `Remove edge between ${selectedNode1.id} and ${selectedNode2.id}`;
       } else {
           removeEdgeBtn.title = "Remove Edge";
       }
    }

    // --- Event Listeners ---
    function setupEventListeners() {
      // Buttons
      addProcessBtn.addEventListener("click", () => openModal("addProcessModal"));
      addResourceBtn.addEventListener("click", () => openModal("addResourceModal"));
      requestEdgeBtn.addEventListener("click", () => addEdge("request"));
      assignEdgeBtn.addEventListener("click", () => addEdge("assignment"));
      releaseResourceBtn.addEventListener("click", releaseResource);
      removeEdgeBtn.addEventListener("click", removeSelectedEdge);
      removeNodeBtn.addEventListener("click", removeSelectedNode);
      editNodeBtn.addEventListener("click", () => { // Open correct edit modal
          if (selectedNode1?.type === 'process') openModal('editProcessModal');
          else if (selectedNode1?.type === 'resource') openModal('editResourceModal');
      });
      visualizeDeadlockBtn.addEventListener("click", startDeadlockVisualization);
      directDeadlockBtn.addEventListener("click", () => detectDeadlock(false)); // Direct detection
      clearSelectionBtn.addEventListener("click", clearSelection);
      scriptButton.addEventListener("click", () => openModal("scriptModal"));
      exportScriptButton.addEventListener("click", () => openModal("exportModal"));
      aiGenerateBtn.addEventListener("click", () => openModal('aiGenerateModal'));
      clearAllButton.addEventListener("click", clearAll);
      aboutButton.addEventListener("click", () => openModal("aboutModal"));
      darkModeToggle.addEventListener("click", toggleDarkMode); // Dark Mode Toggle

      // Visualization Buttons
      stepDeadlockVizBtn.addEventListener("click", stepDeadlockVisualization);
      runDeadlockVizBtn.addEventListener("click", runDeadlockVisualizationToEnd);
      stopDeadlockVizBtn.addEventListener("click", () => stopDeadlockVisualization(true)); // Stop via button logs message

      // Copy Script Button
      copyScriptButton.addEventListener("click", copyScriptToClipboard);


      // Canvas Interaction
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("dblclick", handleDoubleClick); // Handle double click for editing

      // Keyboard Shortcuts
      window.addEventListener("keydown", handleKeyDown);

      // Modal Enter Key Submission
      processIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitAddProcess(); });
      resourceIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitAddResource(); });
      resourceInstancesInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitAddResource(); });
      editProcessIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitEditProcess(); });
      editResourceIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitEditResource(); });
      editResourceInstancesInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitEditResource(); });
      // Don't submit script modal on Enter in textarea, allow newlines
      aiInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && !event.shiftKey) { // Allow Shift+Enter for newlines
              event.preventDefault(); // Prevent default newline in textarea
              submitAiGenerate();
          }
      });
    }

    function handleMouseDown(e) {
      if (isVisualizingDeadlock) return; // Ignore clicks during visualization
      const pos = getMousePos(canvas, e);
      const clickedNode = getNodeAtPos(pos.x, pos.y);

      if (clickedNode){
        draggingNode = clickedNode;
        dragOffsetX = pos.x - clickedNode.x;
        dragOffsetY = pos.y - clickedNode.y;
        // Don't select immediately on mousedown, wait for mouseup without drag
      } else {
        // Clicked on empty space - potentially start clearing selection on mouseup
        draggingNode = null;
      }
      ensureAnimationLoop(); // Start animation loop for potential drag
    }

    function handleMouseMove(e) {
      if (draggingNode && !isVisualizingDeadlock) {
        const pos = getMousePos(canvas, e);
        draggingNode.x = pos.x - dragOffsetX;
        draggingNode.y = pos.y - dragOffsetY;
        // Keep node within canvas bounds (optional)
        const padding = (draggingNode.type === 'process' ? PROCESS_RADIUS : RESOURCE_SIZE / 2) * (draggingNode.currentScale ?? 1.0);
        draggingNode.x = Math.max(padding, Math.min(canvas.clientWidth - padding, draggingNode.x));
        draggingNode.y = Math.max(padding, Math.min(canvas.clientHeight - padding, draggingNode.y));
        ensureAnimationLoop(); // Ensure redraw during drag
      }
    }

    function handleMouseUp(e) {
        if (isVisualizingDeadlock) return;
        const pos = getMousePos(canvas, e);
        const clickedNode = getNodeAtPos(pos.x, pos.y); // Check node at mouseup position

        if (draggingNode) {
            // If we were dragging a node, check if it moved significantly
            const dx = pos.x - (draggingNode.x + dragOffsetX);
            const dy = pos.y - (draggingNode.y + dragOffsetY);
            const movedDistance = Math.sqrt(dx*dx + dy*dy);

            if (movedDistance < 5) { // Threshold to differentiate click from drag
                // It was a click on the node we started dragging
                handleNodeSelection(draggingNode);
            } else {
                 logMessage("INFO", `Moved ${draggingNode.type} '${draggingNode.id}'.`);
            }
        } else if (clickedNode) {
             // Clicked on a node without starting a drag on it (unlikely but possible)
             handleNodeSelection(clickedNode);
        } else {
            // Clicked on empty space, clear selection
            clearSelection();
        }

        draggingNode = null; // End drag operation
        updateButtonStates();
        ensureAnimationLoop(); // Redraw needed for selection changes or final drag position
    }

    function handleDoubleClick(e) {
        if (isVisualizingDeadlock) return;
        const pos = getMousePos(canvas, e);
        const clickedNode = getNodeAtPos(pos.x, pos.y);

        if (clickedNode) {
            // Select the node first
            selectedNode1 = clickedNode;
            selectedNode2 = null;
            updateButtonStates(); // Update buttons to enable edit

            // Open the appropriate edit modal
            if (clickedNode.type === 'process') {
                openModal('editProcessModal');
            } else if (clickedNode.type === 'resource') {
                openModal('editResourceModal');
            }
            ensureAnimationLoop(); // Redraw selection highlight
        }
    }

    function handleNodeSelection(node) {
        if (!node) return;

        if (!selectedNode1) {
            selectedNode1 = node;
        } else if (!selectedNode2) {
            if (node.id !== selectedNode1.id) {
                selectedNode2 = node;
            } else {
                // Clicked the same node again, deselect it
                selectedNode1 = null;
            }
        } else {
            // Both are selected, start fresh with the new click
            selectedNode1 = node;
            selectedNode2 = null;
        }
        deadlockedNodes.clear(); // Clear deadlock highlights when selection changes
        updateButtonStates();
        ensureAnimationLoop();
    }


    function handleKeyDown(e) {
      // Ignore keydowns if a modal is open and the target is an input/textarea
      if (activeModal && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        // Allow Escape key even in modals to close them
        if (e.key === "Escape") {
             closeModal(activeModal);
        }
        return;
      }
       // Allow Escape key during visualization to stop it
       if (isVisualizingDeadlock && e.key === "Escape") {
           stopDeadlockVisualization(true);
           return; // Don't process other keys during viz
       }
       // Allow Space/R during visualization for controls
       if (isVisualizingDeadlock) {
           if (e.key === " ") { // Spacebar
               e.preventDefault(); // Prevent page scroll
               stepDeadlockVisualization();
           } else if (e.key.toUpperCase() === "R") {
               runDeadlockVisualizationToEnd();
           }
           return; // Don't process other keys during viz
       }

      // Normal mode shortcuts (only when no modal is active)
      switch (e.key.toUpperCase()) {
        case "P": addProcessBtn.click(); break;
        case "R": addResourceBtn.click(); break;
        case "Q": if (!requestEdgeBtn.disabled) requestEdgeBtn.click(); break;
        case "A": if (!assignEdgeBtn.disabled) assignEdgeBtn.click(); break;
        case "L": if (!releaseResourceBtn.disabled) releaseResourceBtn.click(); break;
        case "DELETE":
        case "BACKSPACE":
        case "X":
          if (!removeNodeBtn.disabled) removeNodeBtn.click();
          break;
        case "M": // Edit shortcut
           if (!editNodeBtn.disabled) editNodeBtn.click();
           break;
        case "D": if (!visualizeDeadlockBtn.disabled) visualizeDeadlockBtn.click(); break;
        case "K": if (!directDeadlockBtn.disabled) directDeadlockBtn.click(); break; // Direct Detect shortcut
        case "G": // Shortcut for AI Generate
            e.preventDefault(); // Prevent default browser behavior if any
            if (!aiGenerateBtn.disabled) aiGenerateBtn.click(); // Use button click to handle disabled state
            break;
        case "ESCAPE":
            if (selectedNode1) { // Only clear selection if something is selected
                clearSelectionBtn.click();
            } else if (activeModal) { // Close modal if open and no selection
                closeModal(activeModal);
            }
          break;
        case "C": if (!clearAllButton.disabled) clearAllButton.click(); break;
        case "E": if (!exportScriptButton.disabled) exportScriptButton.click(); break; // Export shortcut
        case "T": if (!darkModeToggle.disabled) darkModeToggle.click(); break; // Dark Mode Toggle Shortcut
      }
    }

    // --- Scripting ---
    function runScript(scriptText = scriptInput.value) {
        const commands = scriptText.split(/;|\n/).map(cmd => cmd.trim()).filter(cmd => cmd && !cmd.startsWith("//"));

        logMessage("INFO", `Running script with ${commands.length} commands...`);
        let errors = 0;

        commands.forEach((cmd, index) => {
            const parts = cmd.match(/(?:[^\s"]+|"[^"]*")+/g) || []; // Split by space, respecting quotes
            if (parts.length === 0) return;

            const command = parts[0].toUpperCase();
            const args = parts.slice(1).map(arg => arg.replace(/^"|"$/g, '')); // Remove quotes

            try {
                switch (command) {
                    case "ADD":
                        if (args.length < 2) throw new Error("ADD requires type (P/R) and ID.");
                        const type = args[0].toUpperCase();
                        const id = args[1];
                        if (type === "P") {
                            if (args.length !== 2) throw new Error("ADD P requires ID.");
                            addProcess(id);
                        } else if (type === "R") {
                            if (args.length < 2 || args.length > 3) throw new Error("ADD R requires ID and optional instances.");
                            const instances = args.length === 3 ? parseInt(args[2], 10) : 1;
                            if (isNaN(instances) || instances < 1) throw new Error("Resource instances must be a positive number.");
                            addResource(id, instances);
                        } else {
                            throw new Error(`Invalid type for ADD: ${args[0]}. Use P or R.`);
                        }
                        break;
                    case "REQ":
                    case "REQUEST":
                        if (args.length !== 2) throw new Error("REQ requires ProcessID and ResourceID.");
                        selectNodesByIds(args[0], args[1]);
                        addEdge("request");
                        break;
                    case "ASSIGN":
                        if (args.length !== 2) throw new Error("ASSIGN requires ProcessID and ResourceID.");
                        selectNodesByIds(args[0], args[1]); // Note: Assignment goes R -> P
                        addEdge("assignment");
                        break;
                    case "RELEASE":
                         if (args.length !== 2) throw new Error("RELEASE requires ProcessID and ResourceID.");
                         selectNodesByIds(args[0], args[1]);
                         releaseResource();
                         break;
                    case "REMOVE":
                         if (args.length !== 1 && args.length !== 2) throw new Error("REMOVE requires NodeID or two NodeIDs for an edge.");
                         if (args.length === 1) { // Remove Node
                             selectNodesByIds(args[0], null);
                             removeSelectedNode();
                         } else { // Remove Edge
                             selectNodesByIds(args[0], args[1]);
                             removeSelectedEdge();
                         }
                         break;
                    case "CLEAR":
                        clearAll(); // Consider if confirmation is needed here? For now, script clears directly.
                        break;
                    default:
                        throw new Error(`Unknown command: ${command}`);
                }
            } catch (error) {
                logMessage("ERROR", `Script error on line ${index + 1} ('${cmd}'): ${error.message}`);
                errors++;
            } finally {
                 clearSelection(); // Clear selection after each command attempt
            }
        });

        if (errors > 0) {
            logMessage("WARN", `Script finished with ${errors} error(s).`);
        } else {
            logMessage("SUCCESS", "Script finished successfully.");
        }
        closeModal("scriptModal");
        ensureAnimationLoop(); // Ensure canvas updates after script run
    }

    // Helper for script execution
    function selectNodesByIds(id1, id2) {
        clearSelection();
        selectedNode1 = findNodeById(id1);
        if (!selectedNode1) throw new Error(`Node with ID '${id1}' not found.`);
        if (id2) {
            selectedNode2 = findNodeById(id2);
            if (!selectedNode2) throw new Error(`Node with ID '${id2}' not found.`);
        }
        updateButtonStates(); // Update based on new selection
    }

    function generateScript() {
        let script = "// Generated by RAG Simulator v2.3\n";
        script += "// Date: " + new Date().toISOString() + "\n\n";
        script += "// Processes\n";
        nodes.filter(n => n.type === 'process').forEach(p => {
            script += `ADD P "${p.id}";\n`; // Quote IDs in case they contain spaces
        });
        script += "\n// Resources\n";
        nodes.filter(n => n.type === 'resource').forEach(r => {
            script += `ADD R "${r.id}" ${r.totalInstances};\n`;
        });
        script += "\n// Edges\n";
        edges.forEach(e => {
            const fromNode = findNodeById(e.from);
            const toNode = findNodeById(e.to);
            if (!fromNode || !toNode) return; // Skip if nodes don't exist (shouldn't happen)

            if (e.type === 'request') { // P -> R
                script += `REQ "${e.from}" "${e.to}";\n`;
            } else if (e.type === 'assignment') { // R -> P
                script += `ASSIGN "${e.to}" "${e.from}"; // Note: ASSIGN takes P then R\n`;
            }
        });

        return script;
    }

    function copyScriptToClipboard() {
        const scriptText = exportScriptArea.value;
        navigator.clipboard.writeText(scriptText).then(() => {
            logMessage("SUCCESS", "Script copied to clipboard!");
            copyScriptButton.textContent = "Copied!";
            copyScriptButton.disabled = true;
            setTimeout(() => {
                 copyScriptButton.textContent = "Copy to Clipboard";
                 copyScriptButton.disabled = false;
            }, 1500);
        }).catch(err => {
            logMessage("ERROR", "Failed to copy script: " + err);
            alert("Failed to copy script. Please copy manually.");
        });
    }

    // --- Dark Mode Logic ---
    function applyDarkModePreference() {
        try {
            const savedMode = localStorage.getItem("ragDarkMode");
            if (savedMode === "dark") {
                isDarkMode = true;
                bodyElement.classList.add("dark");
                darkModeToggle.innerHTML = '<i class="fa-solid fa-sun"></i> Light Mode';
                darkModeToggle.title = "Switch to Light Mode (T)";
            } else {
                isDarkMode = false;
                bodyElement.classList.remove("dark"); // Ensure light mode if not dark
                darkModeToggle.innerHTML = '<i class="fa-solid fa-moon"></i> Dark Mode';
                 darkModeToggle.title = "Switch to Dark Mode (T)";
            }
        } catch (e) {
            console.warn("LocalStorage not available, cannot load dark mode preference.", e);
            isDarkMode = false; // Default to light mode
            bodyElement.classList.remove("dark");
            darkModeToggle.innerHTML = '<i class="fa-solid fa-moon"></i> Dark Mode';
            darkModeToggle.title = "Switch to Dark Mode (T)";
        }
        ensureAnimationLoop(); // Redraw with correct colors
    }

    function toggleDarkMode() {
        isDarkMode = !isDarkMode;
        bodyElement.classList.toggle("dark");
        try {
            localStorage.setItem("ragDarkMode", isDarkMode ? "dark" : "light");
            logMessage("INFO", `Switched to ${isDarkMode ? 'Dark' : 'Light'} Mode.`);
        } catch (e) {
            console.warn("LocalStorage not available, cannot save dark mode preference.", e);
             logMessage("WARN", "Could not save dark mode preference (LocalStorage might be disabled).");
        }

        // Update button text/icon
        if (isDarkMode) {
            darkModeToggle.innerHTML = '<i class="fa-solid fa-sun"></i> Light Mode';
            darkModeToggle.title = "Switch to Light Mode (T)";
        } else {
            darkModeToggle.innerHTML = '<i class="fa-solid fa-moon"></i> Dark Mode';
            darkModeToggle.title = "Switch to Dark Mode (T)";
        }
        ensureAnimationLoop(); // Redraw with new theme
    }


    // --- Initialization ---
    function init() {
      // Initial canvas setup (consider moving resize logic here too)
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = canvas.clientHeight * dpr;
      ctx.scale(dpr, dpr);

      // Apply saved dark mode preference
      applyDarkModePreference();

      // Setup listeners
      setupEventListeners();

      // Initial log message
      logMessage("INFO", "RAG Simulator Initialized. Add nodes or run a script.");

      // Show intro modal if not previously dismissed
      let introShown = false;
      try {
        introShown = localStorage.getItem("ragIntroShown") === "true";
      } catch (e) {
        console.warn("LocalStorage not available, cannot check intro preference.", e);
      }
      if (!introShown) {
        openModal("introModal");
      }

      // Initial draw and button state update
      updateButtonStates();
      ensureAnimationLoop(); // Start animation loop if needed (e.g., for initial state)

      // Add resize listener
      window.addEventListener('resize', () => {
          // No need to rescale context here, draw() handles it
          ensureAnimationLoop(); // Redraw on resize
      });
    }

    // --- Start the application ---
    init();

  </script>
</body>
</html>
